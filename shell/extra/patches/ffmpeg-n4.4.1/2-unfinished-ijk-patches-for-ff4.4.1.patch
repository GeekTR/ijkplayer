From 8e40e6811c596f511eb915289814f35302541fe0 Mon Sep 17 00:00:00 2001
From: qianlongxu <qianlongxu@gmail.com>
Date: Tue, 29 Mar 2022 15:48:21 +0800
Subject: [PATCH] unfinished pathes

---
 libavcodec/avcodec.h     |   3 +
 libavcodec/h264_ps.c     |   8 +-
 libavformat/Makefile     |  10 +
 libavformat/allformats.c |   2 +
 libavformat/async.c      |   2 +-
 libavformat/avformat.h   |   5 +
 libavformat/avio.c       |   6 +-
 libavformat/aviobuf.c    |  28 +-
 libavformat/cache.c      |   4 +-
 libavformat/concat.c     |   9 +-
 libavformat/concatdec.c  | 109 ++++++-
 libavformat/file.c       |   3 +-
 libavformat/flv.h        |   1 +
 libavformat/flvdec.c     |  14 +-
 libavformat/hls.c        | 153 +++++++++-
 libavformat/http.c       |  63 +++-
 libavformat/ijkutils.c   |  98 +++++++
 libavformat/isom.h       |   2 +
 libavformat/mov.c        |  53 +++-
 libavformat/network.c    |  46 +++
 libavformat/network.h    |   5 +
 libavformat/protocols.c  |   6 +
 libavformat/tcp.c        | 609 +++++++++++++++++++++++++++++++++++++--
 libavformat/utils.c      |  88 ++++++
 libavutil/Makefile       |   5 +
 libavutil/application.c  | 214 ++++++++++++++
 libavutil/application.h  | 121 ++++++++
 libavutil/dict.c         |  39 ++-
 libavutil/dict.h         |  10 +
 libavutil/dns_cache.c    | 229 +++++++++++++++
 libavutil/dns_cache.h    |  38 +++
 libavutil/error.h        |   4 +
 32 files changed, 1890 insertions(+), 97 deletions(-)
 create mode 100644 libavformat/ijkutils.c
 create mode 100644 libavutil/application.c
 create mode 100644 libavutil/application.h
 create mode 100644 libavutil/dns_cache.c
 create mode 100644 libavutil/dns_cache.h

diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index 8a71c042308..b1dda53bf65 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -512,6 +512,9 @@ typedef struct AVProducerReferenceTime {
  * The decoder will keep a reference to the frame and may reuse it later.
  */
 #define AV_GET_BUFFER_FLAG_REF (1 << 0)
+#define AV_PKT_FLAG_DISPOSABLE 0x0010
+
+#define AV_PKT_FLAG_NEW_SEG 0x8000 ///< The packet is the first packet from a source in concat
 
 /**
  * The encoder will keep a reference to the packet and may reuse it later.
diff --git a/libavcodec/h264_ps.c b/libavcodec/h264_ps.c
index e21c2b56acf..856336c7292 100644
--- a/libavcodec/h264_ps.c
+++ b/libavcodec/h264_ps.c
@@ -483,7 +483,7 @@ int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,
     }
 
     sps->ref_frame_count = get_ue_golomb_31(gb);
-    if (avctx->codec_tag == MKTAG('S', 'M', 'V', '2'))
+    if (avctx && avctx->codec_tag == MKTAG('S', 'M', 'V', '2'))
         sps->ref_frame_count = FFMAX(2, sps->ref_frame_count);
     if (sps->ref_frame_count > MAX_DELAYED_PIC_COUNT) {
         av_log(avctx, AV_LOG_ERROR,
@@ -531,7 +531,7 @@ int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,
         int width  = 16 * sps->mb_width;
         int height = 16 * sps->mb_height;
 
-        if (avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {
+        if (avctx && avctx->flags2 & AV_CODEC_FLAG2_IGNORE_CROP) {
             av_log(avctx, AV_LOG_DEBUG, "discarding sps cropping, original "
                                            "values are l:%d r:%d t:%d b:%d\n",
                    crop_left, crop_right, crop_top, crop_bottom);
@@ -603,7 +603,7 @@ int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,
     if (!sps->sar.den)
         sps->sar.den = 1;
 
-    if (avctx->debug & FF_DEBUG_PICT_INFO) {
+    if (avctx && avctx->debug & FF_DEBUG_PICT_INFO) {
         static const char csp[4][5] = { "Gray", "420", "422", "444" };
         av_log(avctx, AV_LOG_DEBUG,
                "sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %"PRId32"/%"PRId32" b%d reo:%d\n",
@@ -876,7 +876,7 @@ int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avct
     if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])
         pps->chroma_qp_diff = 1;
 
-    if (avctx->debug & FF_DEBUG_PICT_INFO) {
+    if (avctx && avctx->debug & FF_DEBUG_PICT_INFO) {
         av_log(avctx, AV_LOG_DEBUG,
                "pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\n",
                pps_id, pps->sps_id,
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 0f340f74a0c..09a8e429a49 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -4,6 +4,14 @@ DESC = FFmpeg container format library
 HEADERS = avformat.h                                                    \
           avio.h                                                        \
           version.h                                                     \
+          avc.h                                                         \
+          url.h                                                         \
+          internal.h                                                    \
+          avio_internal.h                                               \
+          flv.h                                                         \
+          id3v2.h                                                       \
+          os_support.h                                                  \
+          metadata.h                                                  \
 
 OBJS = allformats.o         \
        avio.o               \
@@ -21,6 +29,8 @@ OBJS = allformats.o         \
        sdp.o                \
        url.o                \
        utils.o              \
+       avc.o                \
+       ijkutils.o           \
 
 OBJS-$(HAVE_LIBC_MSVCRT)                 += file_open.o
 
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index a38fd1f5839..ef4c1563fea 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -494,6 +494,8 @@ extern AVInputFormat  ff_xwma_demuxer;
 extern AVInputFormat  ff_yop_demuxer;
 extern AVInputFormat  ff_yuv4mpegpipe_demuxer;
 extern AVOutputFormat ff_yuv4mpegpipe_muxer;
+extern AVInputFormat  ff_ijklivehook_demuxer;
+extern AVInputFormat  ff_ijklas_demuxer;
 /* image demuxers */
 extern AVInputFormat  ff_image_bmp_pipe_demuxer;
 extern AVInputFormat  ff_image_cri_pipe_demuxer;
diff --git a/libavformat/async.c b/libavformat/async.c
index 5a81507ef16..e992f4a51d2 100644
--- a/libavformat/async.c
+++ b/libavformat/async.c
@@ -483,7 +483,7 @@ static const AVClass async_context_class = {
     .version    = LIBAVUTIL_VERSION_INT,
 };
 
-const URLProtocol ff_async_protocol = {
+URLProtocol ff_async_protocol = {
     .name                = "async",
     .url_open2           = async_open,
     .url_read            = async_read,
diff --git a/libavformat/avformat.h b/libavformat/avformat.h
index 56708c02410..5af828b104a 100644
--- a/libavformat/avformat.h
+++ b/libavformat/avformat.h
@@ -711,6 +711,11 @@ typedef struct AVInputFormat {
      */
     int (*read_header)(struct AVFormatContext *);
 
+    /**
+     * Used by format which open further nested input.
+     */
+    int (*read_header2)(struct AVFormatContext *, AVDictionary **options);
+
     /**
      * Read one packet and put it in 'pkt'. pts and flags are also
      * set. 'avformat_new_stream' can be called only if the flag
diff --git a/libavformat/avio.c b/libavformat/avio.c
index cd9b5d9e7f9..f89e20e71ed 100644
--- a/libavformat/avio.c
+++ b/libavformat/avio.c
@@ -388,10 +388,8 @@ static inline int retry_transfer_wrapper(URLContext *h, uint8_t *buf,
                 }
                 av_usleep(1000);
             }
-        } else if (ret == AVERROR_EOF)
-            return (len > 0) ? len : AVERROR_EOF;
-        else if (ret < 0)
-            return ret;
+        } else if (ret < 1)
+            return (ret < 0 && ret != AVERROR_EOF) ? ret : len;
         if (ret) {
             fast_retries = FFMAX(fast_retries, 2);
             wait_since = 0;
diff --git a/libavformat/aviobuf.c b/libavformat/aviobuf.c
index 518cb111293..41c6a741b16 100644
--- a/libavformat/aviobuf.c
+++ b/libavformat/aviobuf.c
@@ -365,10 +365,6 @@ int avio_feof(AVIOContext *s)
 {
     if(!s)
         return 0;
-    if(s->eof_reached){
-        s->eof_reached=0;
-        fill_buffer(s);
-    }
     return s->eof_reached;
 }
 
@@ -567,14 +563,16 @@ static void fill_buffer(AVIOContext *s)
         len = s->orig_buffer_size;
     }
 
-    len = read_packet_wrapper(s, dst, len);
-    if (len == AVERROR_EOF) {
+    if (s->read_packet)
+        len = s->read_packet(s->opaque, dst, len);
+    else
+        len = 0;
+    if (len <= 0) {
         /* do not modify buffer if EOF reached so that a seek back can
            be done without rereading data */
         s->eof_reached = 1;
-    } else if (len < 0) {
-        s->eof_reached = 1;
-        s->error= len;
+        if (len < 0)
+            s->error = len;
     } else {
         s->pos += len;
         s->buf_ptr = dst;
@@ -640,15 +638,15 @@ int avio_read(AVIOContext *s, unsigned char *buf, int size)
         if (len == 0 || s->write_flag) {
             if((s->direct || size > s->buffer_size) && !s->update_checksum) {
                 // bypass the buffer and read data directly into buf
-                len = read_packet_wrapper(s, buf, size);
-                if (len == AVERROR_EOF) {
+                if(s->read_packet)
+                    len = s->read_packet(s->opaque, buf, size);
+
+                if (len <= 0) {
                     /* do not modify buffer if EOF reached so that a seek back can
                     be done without rereading data */
                     s->eof_reached = 1;
-                    break;
-                } else if (len < 0) {
-                    s->eof_reached = 1;
-                    s->error= len;
+                    if(len<0)
+                        s->error= len;
                     break;
                 } else {
                     s->pos += len;
diff --git a/libavformat/cache.c b/libavformat/cache.c
index 1e19dafc6a5..be6e7fb0e08 100644
--- a/libavformat/cache.c
+++ b/libavformat/cache.c
@@ -207,7 +207,7 @@ static int cache_read(URLContext *h, unsigned char *buf, int size)
     }
 
     r = ffurl_read(c->inner, buf, size);
-    if (r == AVERROR_EOF && size>0) {
+    if (r == 0 && size>0) {
         c->is_true_eof = 1;
         av_assert0(c->end >= c->logical_pos);
     }
@@ -269,7 +269,7 @@ resolve_eof:
                 if (whence == SEEK_SET)
                     size = FFMIN(sizeof(tmp), pos - c->logical_pos);
                 ret = cache_read(h, tmp, size);
-                if (ret == AVERROR_EOF && whence == SEEK_END) {
+                if (ret == 0 && whence == SEEK_END) {
                     av_assert0(c->is_true_eof);
                     goto resolve_eof;
                 }
diff --git a/libavformat/concat.c b/libavformat/concat.c
index 278afd997dd..8ba2cecc7d8 100644
--- a/libavformat/concat.c
+++ b/libavformat/concat.c
@@ -134,20 +134,19 @@ static int concat_read(URLContext *h, unsigned char *buf, int size)
 
     while (size > 0) {
         result = ffurl_read(nodes[i].uc, buf, size);
-        if (result == AVERROR_EOF) {
+        if (result < 0)
+            return total ? total : result;
+        if (!result) {
             if (i + 1 == data->length ||
                 ffurl_seek(nodes[++i].uc, 0, SEEK_SET) < 0)
                 break;
-            result = 0;
         }
-        if (result < 0)
-            return total ? total : result;
         total += result;
         buf   += result;
         size  -= result;
     }
     data->current = i;
-    return total ? total : result;
+    return total;
 }
 
 static int64_t concat_seek(URLContext *h, int64_t pos, int whence)
diff --git a/libavformat/concatdec.c b/libavformat/concatdec.c
index 32d4a99010c..d957f8997ae 100644
--- a/libavformat/concatdec.c
+++ b/libavformat/concatdec.c
@@ -66,6 +66,8 @@ typedef struct {
     ConcatMatchMode stream_match_mode;
     unsigned auto_convert;
     int segment_time_metadata;
+    AVDictionary *options;
+    int error;
 } ConcatContext;
 
 static int concat_probe(const AVProbeData *probe)
@@ -329,27 +331,67 @@ static int open_file(AVFormatContext *avf, unsigned fileno)
 {
     ConcatContext *cat = avf->priv_data;
     ConcatFile *file = &cat->files[fileno];
+    AVFormatContext *new_avf = NULL;
     int ret;
+    AVDictionary *tmp = NULL;
+    AVDictionaryEntry *t = NULL;
+    int fps_flag = 0;
 
-    if (cat->avf)
-        avformat_close_input(&cat->avf);
-
-    cat->avf = avformat_alloc_context();
-    if (!cat->avf)
+    new_avf = avformat_alloc_context();
+    if (!new_avf)
         return AVERROR(ENOMEM);
 
-    cat->avf->flags |= avf->flags & ~AVFMT_FLAG_CUSTOM_IO;
-    cat->avf->interrupt_callback = avf->interrupt_callback;
+    new_avf->flags |= avf->flags & ~AVFMT_FLAG_CUSTOM_IO;
 
-    if ((ret = ff_copy_whiteblacklists(cat->avf, avf)) < 0)
+#ifdef FF_API_LAVF_KEEPSIDE_FLAG
+    if (avf->flags & AVFMT_FLAG_KEEP_SIDE_DATA) {
+        new_avf->flags |= AVFMT_FLAG_KEEP_SIDE_DATA;
+    }
+#endif
+    new_avf->interrupt_callback = avf->interrupt_callback;
+
+    if ((ret = ff_copy_whiteblacklists(new_avf, avf)) < 0)
         return ret;
 
-    if ((ret = avformat_open_input(&cat->avf, file->url, NULL, NULL)) < 0 ||
-        (ret = avformat_find_stream_info(cat->avf, NULL)) < 0) {
+    if (cat->options)
+        av_dict_copy(&tmp, cat->options, 0);
+
+    av_dict_set_int(&tmp, "cur_file_no", fileno, 0);
+
+    t = av_dict_get(tmp, "skip-calc-frame-rate", NULL, AV_DICT_MATCH_CASE);
+    if (t) {
+        fps_flag = (int) strtol(t->value, NULL, 10);
+        if (fps_flag > 0) {
+            av_dict_set_int(&new_avf->metadata, "skip-calc-frame-rate", fps_flag, 0);
+        }
+    }
+
+    t = av_dict_get(tmp, "nb-streams", NULL, AV_DICT_MATCH_CASE);
+    if (t) {
+        int nb_streams = (int) strtol(t->value, NULL, 10);
+        if (nb_streams > 0) {
+            av_dict_set_int(&new_avf->metadata, "nb-streams", nb_streams, 0);
+            av_dict_set_int(&cat->options, "nb-streams", 0, 0);
+        }
+    }
+
+    ret = avformat_open_input(&new_avf, file->url, NULL, &tmp);
+    av_dict_free(&tmp);
+    if (ret < 0 ||
+        (ret = avformat_find_stream_info(new_avf, NULL)) < 0) {
         av_log(avf, AV_LOG_ERROR, "Impossible to open '%s'\n", file->url);
-        avformat_close_input(&cat->avf);
+        avformat_close_input(&new_avf);
         return ret;
     }
+
+    if (!new_avf)
+        return 0;
+
+    if (cat->avf)
+        avformat_close_input(&cat->avf);
+
+    avf->bit_rate = new_avf->bit_rate;
+    cat->avf      = new_avf;
     cat->cur_file = file;
     file->start_time = !fileno ? 0 :
                        cat->files[fileno - 1].start_time +
@@ -389,11 +431,12 @@ static int concat_read_close(AVFormatContext *avf)
     }
     if (cat->avf)
         avformat_close_input(&cat->avf);
+    av_dict_free(&cat->options);
     av_freep(&cat->files);
     return 0;
 }
 
-static int concat_read_header(AVFormatContext *avf)
+static int concat_read_header(AVFormatContext *avf, AVDictionary **options)
 {
     ConcatContext *cat = avf->priv_data;
     AVBPrint bp;
@@ -403,6 +446,9 @@ static int concat_read_header(AVFormatContext *avf)
     ConcatFile *file = NULL;
     int64_t ret, time = 0;
 
+    if (options && *options)
+        av_dict_copy(&cat->options, *options, 0);
+
     av_bprint_init(&bp, 0, AV_BPRINT_SIZE_UNLIMITED);
 
     while ((ret = ff_read_line_to_bprint_overwrite(avf->pb, &bp)) >= 0) {
@@ -567,6 +613,7 @@ static int packet_after_outpoint(ConcatContext *cat, AVPacket *pkt)
     return 0;
 }
 
+#define CONCAT_MAX_OPEN_TRY 3
 static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt)
 {
     ConcatContext *cat = avf->priv_data;
@@ -574,6 +621,13 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt)
     int64_t delta;
     ConcatStream *cs;
     AVStream *st;
+    int try_counter = 0;
+    int is_new_st = 0;
+
+    if (cat->error) {
+        ret = cat->error;
+        return ret;
+    }
 
     if (cat->eof)
         return AVERROR_EOF;
@@ -584,19 +638,27 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt)
     while (1) {
         ret = av_read_frame(cat->avf, pkt);
         if (ret == AVERROR_EOF) {
+            is_new_st = 1;
             if ((ret = open_next_file(avf)) < 0)
-                return ret;
+                goto open_fail;
             continue;
         }
-        if (ret < 0)
+        if (ret < 0) {
+            if (avf->pb && cat->avf->pb)
+                avf->pb->error = cat->avf->pb->error;
             return ret;
+        }
+        if (is_new_st) {
+            pkt->flags |= AV_PKT_FLAG_NEW_SEG;
+            is_new_st = 0;
+        }
         if ((ret = match_streams(avf)) < 0) {
             return ret;
         }
         if (packet_after_outpoint(cat, pkt)) {
             av_packet_unref(pkt);
             if ((ret = open_next_file(avf)) < 0)
-                return ret;
+                goto open_fail;
             continue;
         }
         cs = &cat->cur_file->streams[pkt->stream_index];
@@ -605,6 +667,16 @@ static int concat_read_packet(AVFormatContext *avf, AVPacket *pkt)
             continue;
         }
         break;
+open_fail:
+        ++try_counter;
+        if (try_counter > CONCAT_MAX_OPEN_TRY) {
+            cat->error = ret;
+            if (avf->pb && ret != AVERROR_EOF)
+               avf->pb->error = ret;
+            return AVERROR_EOF;
+        }
+
+        av_log(avf, AV_LOG_WARNING, "open_next_file() failed (%d)\n", try_counter);
     }
     if ((ret = filter_packet(avf, cs, pkt)) < 0)
         return ret;
@@ -735,6 +807,11 @@ static int concat_seek(AVFormatContext *avf, int stream,
     AVFormatContext *cur_avf_saved = cat->avf;
     int ret;
 
+    /* reset error/complete state */
+    cat->error = 0;
+
+    if (!cat->seekable)
+        return AVERROR(ESPIPE); /* XXX: can we use it? */
     if (flags & (AVSEEK_FLAG_BYTE | AVSEEK_FLAG_FRAME))
         return AVERROR(ENOSYS);
     cat->avf = NULL;
@@ -780,7 +857,7 @@ AVInputFormat ff_concat_demuxer = {
     .long_name      = NULL_IF_CONFIG_SMALL("Virtual concatenation script"),
     .priv_data_size = sizeof(ConcatContext),
     .read_probe     = concat_probe,
-    .read_header    = concat_read_header,
+    .read_header2   = concat_read_header,
     .read_packet    = concat_read_packet,
     .read_close     = concat_read_close,
     .read_seek2     = concat_seek,
diff --git a/libavformat/file.c b/libavformat/file.c
index 8303436be09..a60e2867dfc 100644
--- a/libavformat/file.c
+++ b/libavformat/file.c
@@ -395,7 +395,7 @@ static int pipe_open(URLContext *h, const char *filename, int flags)
     setmode(fd, O_BINARY);
 #endif
     c->fd = fd;
-    h->is_streamed = 1;
+    h->is_streamed = 0;
     return 0;
 }
 
@@ -404,6 +404,7 @@ const URLProtocol ff_pipe_protocol = {
     .url_open            = pipe_open,
     .url_read            = file_read,
     .url_write           = file_write,
+    .url_seek            = file_seek,
     .url_get_file_handle = file_get_handle,
     .url_check           = file_check,
     .priv_data_size      = sizeof(FileContext),
diff --git a/libavformat/flv.h b/libavformat/flv.h
index 3571b90279c..91f006520ca 100644
--- a/libavformat/flv.h
+++ b/libavformat/flv.h
@@ -110,6 +110,7 @@ enum {
     FLV_CODECID_H264    = 7,
     FLV_CODECID_REALH263= 8,
     FLV_CODECID_MPEG4   = 9,
+    FLV_CODECID_HEVC    = 12,
 };
 
 enum {
diff --git a/libavformat/flvdec.c b/libavformat/flvdec.c
index 79c810f9638..967406eee33 100644
--- a/libavformat/flvdec.c
+++ b/libavformat/flvdec.c
@@ -320,6 +320,8 @@ static int flv_same_video_codec(AVCodecParameters *vpar, int flags)
         return vpar->codec_id == AV_CODEC_ID_VP6A;
     case FLV_CODECID_H264:
         return vpar->codec_id == AV_CODEC_ID_H264;
+    case FLV_CODECID_HEVC:
+        return vpar->codec_id == AV_CODEC_ID_HEVC;
     default:
         return vpar->codec_tag == flv_codecid;
     }
@@ -360,6 +362,11 @@ static int flv_set_video_codec(AVFormatContext *s, AVStream *vstream,
         }
         ret = 1;     // 1 byte body size adjustment for flv_read_packet()
         break;
+    case FLV_CODECID_HEVC:
+        par->codec_id = AV_CODEC_ID_HEVC;
+        vstream->need_parsing = AVSTREAM_PARSE_NONE;
+        ret = 3;     // not 4, reading packet type will consume one byte
+        break;
     case FLV_CODECID_H264:
         par->codec_id = AV_CODEC_ID_H264;
         vstream->need_parsing = AVSTREAM_PARSE_HEADERS;
@@ -1241,7 +1248,8 @@ retry_duration:
 
     if (st->codecpar->codec_id == AV_CODEC_ID_AAC ||
         st->codecpar->codec_id == AV_CODEC_ID_H264 ||
-        st->codecpar->codec_id == AV_CODEC_ID_MPEG4) {
+        st->codecpar->codec_id == AV_CODEC_ID_MPEG4 ||
+        st->codecpar->codec_id == AV_CODEC_ID_HEVC) {
         int type = avio_r8(s->pb);
         size--;
 
@@ -1250,7 +1258,7 @@ retry_duration:
             goto leave;
         }
 
-        if (st->codecpar->codec_id == AV_CODEC_ID_H264 || st->codecpar->codec_id == AV_CODEC_ID_MPEG4) {
+        if (st->codecpar->codec_id == AV_CODEC_ID_H264 || st->codecpar->codec_id == AV_CODEC_ID_MPEG4 || st->codecpar->codec_id == AV_CODEC_ID_HEVC) {
             // sign extension
             int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000;
             pts = av_sat_add64(dts, cts);
@@ -1266,7 +1274,7 @@ retry_duration:
             }
         }
         if (type == 0 && (!st->codecpar->extradata || st->codecpar->codec_id == AV_CODEC_ID_AAC ||
-            st->codecpar->codec_id == AV_CODEC_ID_H264)) {
+            st->codecpar->codec_id == AV_CODEC_ID_H264 || st->codecpar->codec_id == AV_CODEC_ID_HEVC)) {
             AVDictionaryEntry *t;
 
             if (st->codecpar->extradata) {
diff --git a/libavformat/hls.c b/libavformat/hls.c
index 597bea7f25d..3f5501f6ec6 100644
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -2,6 +2,7 @@
  * Apple HTTP Live Streaming demuxer
  * Copyright (c) 2010 Martin Storsjo
  * Copyright (c) 2013 Anssi Hannula
+ * Copyright (c) 2011 Cedirc Fung (wolfplanet@gmail.com)
  *
  * This file is part of FFmpeg.
  *
@@ -66,7 +67,9 @@ enum KeyType {
 };
 
 struct segment {
+    int64_t previous_duration;
     int64_t duration;
+    int64_t start_time;
     int64_t url_offset;
     int64_t size;
     char *url;
@@ -213,6 +216,8 @@ typedef struct HLSContext {
     int http_multiple;
     int http_seekable;
     AVIOContext *playlist_pb;
+    int hls_io_protocol_enable;
+    char * hls_io_protocol;
 } HLSContext;
 
 static void free_segment_dynarray(struct segment **segments, int n_segments)
@@ -630,6 +635,10 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
     int ret;
     int is_http = 0;
 
+    av_dict_copy(&tmp, opts, 0);
+    av_dict_copy(&tmp, opts2, 0);
+    av_dict_set(&tmp, "seekable", "1", 0);
+
     if (av_strstart(url, "crypto", NULL)) {
         if (url[6] == '+' || url[6] == ':')
             proto_name = avio_find_protocol_name(url + 7);
@@ -657,6 +666,8 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (c->hls_io_protocol_enable) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -712,12 +723,13 @@ static int parse_playlist(HLSContext *c, const char *url,
                           struct playlist *pls, AVIOContext *in)
 {
     int ret = 0, is_segment = 0, is_variant = 0;
-    int64_t duration = 0;
+    int64_t duration = 0, previous_duration1 = 0, previous_duration = 0, total_duration = 0;
     enum KeyType key_type = KEY_NONE;
     uint8_t iv[16] = "";
     int has_iv = 0;
     char key[MAX_URL_SIZE] = "";
     char line[MAX_URL_SIZE];
+    char io_url[MAX_URL_SIZE] = "";
     const char *ptr;
     int close_in = 0;
     int64_t seg_offset = 0;
@@ -744,10 +756,19 @@ static int parse_playlist(HLSContext *c, const char *url,
             in = NULL;
         }
     }
+    int start_seq_no = -1;
 
     if (!in) {
         AVDictionary *opts = NULL;
         av_dict_copy(&opts, c->avio_opts, 0);
+        /* Some HLS servers don't like being sent the range header */
+        av_dict_set(&opts, "seekable", "0", 0);
+
+        // broker prior HTTP options that should be consistent across requests
+        av_dict_set(&opts, "user_agent", c->user_agent, 0);
+        av_dict_set(&opts, "cookies", c->cookies, 0);
+        av_dict_set(&opts, "headers", c->headers, 0);
+        av_dict_set(&opts, "http_proxy", c->http_proxy, 0);
 
         if (c->http_persistent)
             av_dict_set(&opts, "multiple_requests", "1", 0);
@@ -825,7 +846,11 @@ static int parse_playlist(HLSContext *c, const char *url,
                         "INT64_MAX, mask out the highest bit\n");
                 seq_no &= INT64_MAX;
             }
-            pls->start_seq_no = seq_no;
+            /* Some buggy HLS servers write #EXT-X-MEDIA-SEQUENCE more than once */
+            if (start_seq_no < 0) {
+                start_seq_no = seq_no;
+                pls->start_seq_no = seq_no;
+            }
         } else if (av_strstart(line, "#EXT-X-PLAYLIST-TYPE:", &ptr)) {
             ret = ensure_playlist(c, &pls, url);
             if (ret < 0)
@@ -871,6 +896,8 @@ static int parse_playlist(HLSContext *c, const char *url,
         } else if (av_strstart(line, "#EXT-X-ENDLIST", &ptr)) {
             if (pls)
                 pls->finished = 1;
+        } else if (av_strstart(line, "#EXT-X-DISCONTINUITY", &ptr)) {
+            previous_duration = previous_duration1;
         } else if (av_strstart(line, "#EXTINF:", &ptr)) {
             is_segment = 1;
             duration   = atof(ptr) * AV_TIME_BASE;
@@ -900,6 +927,12 @@ static int parse_playlist(HLSContext *c, const char *url,
                     ret = AVERROR(ENOMEM);
                     goto fail;
                 }
+                previous_duration1 += duration;
+                seg->previous_duration = previous_duration;
+                seg->start_time = total_duration;
+                total_duration += duration;
+                seg->duration = duration;
+                seg->key_type = key_type;
                 if (has_iv) {
                     memcpy(seg->iv, iv, sizeof(iv));
                 } else {
@@ -926,14 +959,29 @@ static int parse_playlist(HLSContext *c, const char *url,
                 }
 
                 ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, line);
-                if (!tmp_str[0]) {
-                    ret = AVERROR_INVALIDDATA;
-                    if (seg->key)
-                        av_free(seg->key);
-                    av_free(seg);
-                    goto fail;
+                
+                if (c->hls_io_protocol_enable) {
+                    char * url_start = NULL;
+                    if (c->hls_io_protocol) {
+                        strcpy(io_url, c->hls_io_protocol);
+                    } else if ((url_start =  strstr(url,"http://")) ||
+                                (url_start =  strstr(url,"https://"))) {
+                        strncpy(io_url, url, url_start - url);
+                    }
+                    av_strlcat(io_url, tmp_str, sizeof(io_url));
+                    seg->url = av_strdup(io_url);
+                    memset(io_url, 0, sizeof(io_url));
+                } else {
+                    if (!tmp_str[0]) {
+                        ret = AVERROR_INVALIDDATA;
+                        if (seg->key)
+                            av_free(seg->key);
+                        av_free(seg);
+                        goto fail;
+                    }
+                    seg->url = av_strdup(tmp_str);
                 }
-                seg->url = av_strdup(tmp_str);
+
                 if (!seg->url) {
                     av_free(seg->key);
                     av_free(seg);
@@ -1521,7 +1569,13 @@ reload:
             av_log(v->parent, AV_LOG_WARNING, "Failed to open segment %"PRId64" of playlist %d\n",
                    v->cur_seq_no,
                    v->index);
-            v->cur_seq_no += 1;
+
+            if (c->hls_io_protocol_enable && (parse_playlist(c, v->url, v, NULL)) < 0) {
+                av_log(NULL, AV_LOG_INFO, "Failed to reload playlist %d\n",
+                       v->index);
+            } else {
+                v->cur_seq_no += 1;
+            }
             goto reload;
         }
         just_opened = 1;
@@ -1855,7 +1909,7 @@ static int hls_close(AVFormatContext *s)
     return 0;
 }
 
-static int hls_read_header(AVFormatContext *s)
+static int hls_read_header(AVFormatContext *s, AVDictionary **options)
 {
     HLSContext *c = s->priv_data;
     int ret = 0, i;
@@ -1870,6 +1924,18 @@ static int hls_read_header(AVFormatContext *s)
 
     if ((ret = save_avio_options(s)) < 0)
         goto fail;
+    if (options && *options)
+        av_dict_copy(&c->avio_opts, *options, 0);
+
+    if (u) {
+        // get the previous user agent & set back to null if string size is zero
+        update_options(&c->user_agent, "user_agent", u);
+
+        // get the previous cookies & set back to null if string size is zero
+        update_options(&c->cookies, "cookies", u);
+
+        // get the previous headers & set back to null if string size is zero
+        update_options(&c->headers, "headers", u);
 
     /* XXX: Some HLS servers don't like being sent the range header,
        in this case, need to  setting http_seekable = 0 to disable
@@ -2162,12 +2228,24 @@ static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)
          * stream */
         if (pls->needed && !pls->pkt->data) {
             while (1) {
+                int64_t pkt_ts;
                 int64_t ts_diff;
                 AVRational tb;
                 ret = av_read_frame(pls->ctx, pls->pkt);
                 if (ret < 0) {
-                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF)
+                    //when error occur try to renew m3u8
+                    if (c->hls_io_protocol_enable && (parse_playlist(c, pls->url, pls, NULL)) < 0) {
+                        av_log(NULL, AV_LOG_INFO, "Failed to reload playlist %d\n",
+                               pls->index);
+                    }
+
+                    if (!avio_feof(&pls->pb) && ret != AVERROR_EOF) {
                         return ret;
+<<<<<<< ours
+=======
+                    }
+                    reset_packet(&pls->pkt);
+>>>>>>> theirs
                     break;
                 } else {
                     /* stream_index check prevents matching picture attachments etc. */
@@ -2176,10 +2254,23 @@ static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)
                         fill_timing_for_id3_timestamped_stream(pls);
                     }
 
+<<<<<<< ours
                     if (c->first_timestamp == AV_NOPTS_VALUE &&
                         pls->pkt->dts       != AV_NOPTS_VALUE)
                         c->first_timestamp = av_rescale_q(pls->pkt->dts,
                             get_timebase(pls), AV_TIME_BASE_Q);
+=======
+                    if (pls->pkt.pts != AV_NOPTS_VALUE)
+                        pkt_ts =  pls->pkt.pts;
+                    else if (pls->pkt.dts != AV_NOPTS_VALUE)
+                        pkt_ts =  pls->pkt.dts;
+                    else
+                        pkt_ts = AV_NOPTS_VALUE;
+
+
+                    c->first_timestamp = s->start_time != AV_NOPTS_VALUE ? s->start_time : 0;
+
+>>>>>>> theirs
                 }
 
                 if (pls->seek_timestamp == AV_NOPTS_VALUE)
@@ -2188,15 +2279,20 @@ static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)
                 if (pls->seek_stream_index < 0 ||
                     pls->seek_stream_index == pls->pkt->stream_index) {
 
-                    if (pls->pkt->dts == AV_NOPTS_VALUE) {
+                    if (pls->pkt->dts == AV_NOPTS_VALUE || pkt_ts == AV_NOPTS_VALUE) {
                         pls->seek_timestamp = AV_NOPTS_VALUE;
                         break;
                     }
 
                     tb = get_timebase(pls);
+<<<<<<< ours
                     ts_diff = av_rescale_rnd(pls->pkt->dts, AV_TIME_BASE,
+=======
+                    ts_diff = av_rescale_rnd(pkt_ts, AV_TIME_BASE,
+>>>>>>> theirs
                                             tb.den, AV_ROUND_DOWN) -
                             pls->seek_timestamp;
+
                     if (ts_diff >= 0 && (pls->seek_flags  & AVSEEK_FLAG_ANY ||
                                         pls->pkt->flags & AV_PKT_FLAG_KEY)) {
                         pls->seek_timestamp = AV_NOPTS_VALUE;
@@ -2279,6 +2375,28 @@ static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)
             }
         }
 
+        if (c->playlists[minplaylist]->finished) {
+            struct playlist *pls = c->playlists[minplaylist];
+            int seq_no = pls->cur_seq_no - pls->start_seq_no;
+            if (seq_no < pls->n_segments && s->streams[pkt->stream_index]) {
+                struct segment *seg = pls->segments[seq_no];
+                int64_t pred = av_rescale_q(seg->previous_duration,
+                                            AV_TIME_BASE_Q,
+                                            s->streams[pkt->stream_index]->time_base);
+                int64_t max_ts = av_rescale_q(seg->start_time + seg->duration,
+                                              AV_TIME_BASE_Q,
+                                              s->streams[pkt->stream_index]->time_base);
+                /* EXTINF duration is not precise enough */
+                max_ts += 2 * AV_TIME_BASE;
+                if (s->start_time > 0) {
+                    max_ts += av_rescale_q(s->start_time,
+                                           AV_TIME_BASE_Q,
+                                           s->streams[pkt->stream_index]->time_base);
+                }
+                if (pkt->dts != AV_NOPTS_VALUE && pkt->dts + pred < max_ts) pkt->dts += pred;
+                if (pkt->pts != AV_NOPTS_VALUE && pkt->pts + pred < max_ts) pkt->pts += pred;
+            }
+        }
         return 0;
     }
     return AVERROR_EOF;
@@ -2397,8 +2515,15 @@ static const AVOption hls_options[] = {
         OFFSET(http_persistent), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, FLAGS },
     {"http_multiple", "Use multiple HTTP connections for fetching segments",
         OFFSET(http_multiple), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, FLAGS},
+<<<<<<< ours
     {"http_seekable", "Use HTTP partial requests, 0 = disable, 1 = enable, -1 = auto",
         OFFSET(http_seekable), AV_OPT_TYPE_BOOL, { .i64 = -1}, -1, 1, FLAGS},
+=======
+    {"hls_io_protocol", "force segment io protocol",
+        OFFSET(hls_io_protocol), AV_OPT_TYPE_STRING, {.str= NULL}, 0, 0, FLAGS},
+    {"hls_io_protocol_enable", "enable auto copy segment io protocol from playlist",
+        OFFSET(hls_io_protocol_enable), AV_OPT_TYPE_BOOL, {.i64= 0}, 0, 1, FLAGS},
+>>>>>>> theirs
     {NULL}
 };
 
@@ -2416,7 +2541,7 @@ AVInputFormat ff_hls_demuxer = {
     .priv_data_size = sizeof(HLSContext),
     .flags          = AVFMT_NOGENSEARCH | AVFMT_TS_DISCONT,
     .read_probe     = hls_probe,
-    .read_header    = hls_read_header,
+    .read_header2   = hls_read_header,
     .read_packet    = hls_read_packet,
     .read_close     = hls_close,
     .read_seek      = hls_read_seek,
diff --git a/libavformat/http.c b/libavformat/http.c
index fb2d9306bd2..1c54727fc3e 100644
--- a/libavformat/http.c
+++ b/libavformat/http.c
@@ -31,6 +31,7 @@
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
 #include "libavutil/parseutils.h"
+#include "libavutil/application.h"
 
 #include "avformat.h"
 #include "http.h"
@@ -126,6 +127,9 @@ typedef struct HTTPContext {
     int is_multi_client;
     HandshakeState handshake_step;
     int is_connected_server;
+    char *tcp_hook;
+    char * app_ctx_intptr;
+    AVApplicationContext *app_ctx;
 } HTTPContext;
 
 #define OFFSET(x) offsetof(HTTPContext, x)
@@ -170,6 +174,8 @@ static const AVOption options[] = {
     { "listen", "listen on HTTP", OFFSET(listen), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 2, D | E },
     { "resource", "The resource requested by a client", OFFSET(resource), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, E },
     { "reply_code", "The http status code to return to a client", OFFSET(reply_code), AV_OPT_TYPE_INT, { .i64 = 200}, INT_MIN, 599, E},
+    { "http-tcp-hook", "hook protocol on tcp", OFFSET(tcp_hook), AV_OPT_TYPE_STRING, { .str = "tcp" }, 0, 0, D | E },
+    { "ijkapplication", "AVApplicationContext", OFFSET(app_ctx_intptr), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, .flags = D },
     { NULL }
 };
 
@@ -198,8 +204,11 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
     char path1[MAX_URL_SIZE], sanitized_path[MAX_URL_SIZE];
     char buf[1024], urlbuf[MAX_URL_SIZE];
     int port, use_proxy, err, location_changed = 0;
+    char prev_location[4096];
     HTTPContext *s = h->priv_data;
 
+    lower_proto = s->tcp_hook;
+
     av_url_split(proto, sizeof(proto), auth, sizeof(auth),
                  hostname, sizeof(hostname), &port,
                  path1, sizeof(path1), s->location);
@@ -210,6 +219,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
                  proxy_path && av_strstart(proxy_path, "http://", NULL);
 
     if (!strcmp(proto, "https")) {
+        av_dict_set_int(options, "fastopen", 0, 0);
         lower_proto = "tls";
         use_proxy   = 0;
         if (port < 0)
@@ -250,6 +260,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
     ff_url_join(buf, sizeof(buf), lower_proto, NULL, hostname, port, NULL);
 
     if (!s->hd) {
+        av_dict_set_intptr(options, "ijkapplication", (uintptr_t)s->app_ctx, 0);
         err = ffurl_open_whitelist(&s->hd, buf, AVIO_FLAG_READ_WRITE,
                                    &h->interrupt_callback, options,
                                    h->protocol_whitelist, h->protocol_blacklist, h);
@@ -257,6 +268,7 @@ static int http_open_cnx_internal(URLContext *h, AVDictionary **options)
             return err;
     }
 
+    av_strlcpy(prev_location, s->location, sizeof(prev_location));
     err = http_connect(h, path, local_path, hoststr,
                        auth, proxyauth, &location_changed);
     if (err < 0)
@@ -617,6 +629,8 @@ static int http_open(URLContext *h, const char *uri, int flags,
     HTTPContext *s = h->priv_data;
     int ret;
 
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
     if( s->seekable == 1 )
         h->is_streamed = 0;
     else
@@ -646,8 +660,13 @@ static int http_open(URLContext *h, const char *uri, int flags,
     if (s->listen) {
         return http_listen(h, uri, flags, options);
     }
+    av_application_will_http_open(s->app_ctx, (void*)h, uri);
     ret = http_open_cnx(h, options);
+<<<<<<< ours
 bail_out:
+=======
+    av_application_did_http_open(s->app_ctx, (void*)h, uri, ret, s->http_code, s->filesize);
+>>>>>>> theirs
     if (ret < 0)
         av_dict_free(&s->chained_options);
     return ret;
@@ -1283,6 +1302,11 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,
     AVBPrint request;
     char *authstr = NULL, *proxyauthstr = NULL;
     uint64_t off = s->off;
+<<<<<<< ours
+=======
+    uint64_t filesize = s->filesize;
+    int len = 0;
+>>>>>>> theirs
     const char *method;
     int send_expect_100 = 0;
 
@@ -1427,6 +1451,15 @@ static int http_connect(URLContext *h, const char *path, const char *local_path,
     if (*new_location)
         s->off = off;
 
+    /* Some buggy servers may missing 'Content-Range' header for range request */
+    if (off > 0 && s->off <= 0 && (off + s->filesize == filesize)) {
+        av_log(NULL, AV_LOG_WARNING,
+               "try to fix missing 'Content-Range' at server side (%"PRId64",%"PRId64") => (%"PRId64",%"PRId64")",
+               s->off, s->filesize, off, filesize);
+        s->off = off;
+        s->filesize = filesize;
+    }
+
     err = (off == s->off) ? 0 : -1;
 done:
     av_freep(&authstr);
@@ -1458,16 +1491,8 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
                    "Chunked encoding data size: %"PRIu64"\n",
                     s->chunksize);
 
-            if (!s->chunksize && s->multiple_requests) {
-                http_get_line(s, line, sizeof(line)); // read empty chunk
-                s->chunkend = 1;
+            if (!s->chunksize)
                 return 0;
-            }
-            else if (!s->chunksize) {
-                av_log(h, AV_LOG_DEBUG, "Last chunk received, closing conn\n");
-                ffurl_closep(&s->hd);
-                return 0;
-            }
             else if (s->chunksize == UINT64_MAX) {
                 av_log(h, AV_LOG_ERROR, "Invalid chunk size %"PRIu64"\n",
                        s->chunksize);
@@ -1488,9 +1513,22 @@ static int http_buf_read(URLContext *h, uint8_t *buf, int size)
         uint64_t target_end = s->end_off ? s->end_off : s->filesize;
         if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)
             return AVERROR_EOF;
+<<<<<<< ours
         len = ffurl_read(s->hd, buf, size);
         if ((!len || len == AVERROR_EOF) &&
             (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {
+=======
+
+        len = size;
+        if (s->filesize > 0 && s->filesize != UINT64_MAX && s->filesize != 2147483647) {
+            int64_t unread = s->filesize - s->off;
+            if (len > unread)
+                len = (int)unread;
+        }
+        if (len > 0)
+            len = ffurl_read(s->hd, buf, len);
+        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {
+>>>>>>> theirs
             av_log(h, AV_LOG_ERROR,
                    "Stream ends prematurely at %"PRIu64", should be %"PRIu64"\n",
                    s->off, target_end
@@ -1813,7 +1851,9 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
     s->hd = NULL;
 
     /* if it fails, continue on old connection */
+    av_application_will_http_seek(s->app_ctx, (void*)h, s->location, off);
     if ((ret = http_open_cnx(h, &options)) < 0) {
+        av_application_did_http_seek(s->app_ctx, (void*)h, s->location, off, ret, s->http_code);
         av_dict_free(&options);
         memcpy(s->buffer, old_buf, old_buf_size);
         s->buf_ptr = s->buffer;
@@ -1822,6 +1862,7 @@ static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int fo
         s->off     = old_off;
         return ret;
     }
+    av_application_did_http_seek(s->app_ctx, (void*)h, s->location, off, ret, s->http_code);
     av_dict_free(&options);
     ffurl_close(old_hd);
     return off;
@@ -1914,6 +1955,8 @@ static int http_proxy_open(URLContext *h, const char *uri, int flags)
     char *authstr;
     int new_loc;
 
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
     if( s->seekable == 1 )
         h->is_streamed = 0;
     else
@@ -1926,7 +1969,7 @@ static int http_proxy_open(URLContext *h, const char *uri, int flags)
     if (*path == '/')
         path++;
 
-    ff_url_join(lower_url, sizeof(lower_url), "tcp", NULL, hostname, port,
+    ff_url_join(lower_url, sizeof(lower_url), s->tcp_hook, NULL, hostname, port,
                 NULL);
 redo:
     ret = ffurl_open_whitelist(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,
diff --git a/libavformat/ijkutils.c b/libavformat/ijkutils.c
new file mode 100644
index 00000000000..c6d013486d2
--- /dev/null
+++ b/libavformat/ijkutils.c
@@ -0,0 +1,98 @@
+/*
+ * utils.c
+ *
+ * Copyright (c) 2003 Fabrice Bellard
+ * Copyright (c) 2013 Zhang Rui <bbcallen@gmail.com>
+ *
+ * This file is part of ijkPlayer.
+ *
+ * ijkPlayer is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * ijkPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with ijkPlayer; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#include "url.h"
+#include "avformat.h"
+
+
+#define IJK_FF_PROTOCOL(x)                                                                          \
+extern URLProtocol ff_##x##_protocol;                                                               \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size);                        \
+int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size)                         \
+{                                                                                                   \
+    if (protocol_size != sizeof(URLProtocol)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_protocol: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_protocol, protocol, protocol_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_PROTOCOL(x)                                       \
+IJK_FF_PROTOCOL(x);                                                 \
+static const AVClass ijk_##x##_context_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+URLProtocol ff_##x##_protocol = {                                   \
+    .name                = #x,                                      \
+    .url_open2           = ijkdummy_open,                           \
+    .priv_data_size      = 1,                                       \
+    .priv_data_class     = &ijk_##x##_context_class,                \
+};
+
+static int ijkdummy_open(URLContext *h, const char *arg, int flags, AVDictionary **options)
+{
+    return -1;
+}
+
+IJK_FF_PROTOCOL(async);
+IJK_DUMMY_PROTOCOL(ijkmediadatasource);
+IJK_DUMMY_PROTOCOL(ijkhttphook);
+IJK_DUMMY_PROTOCOL(ijklongurl);
+IJK_DUMMY_PROTOCOL(ijksegment);
+IJK_DUMMY_PROTOCOL(ijktcphook);
+IJK_DUMMY_PROTOCOL(ijkio);
+
+#define IJK_FF_DEMUXER(x)                                                                          \
+extern AVInputFormat ff_##x##_demuxer;                                                               \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size);                        \
+int ijkav_register_##x##_demuxer(AVInputFormat *demuxer, int demuxer_size)                         \
+{                                                                                                   \
+    if (demuxer_size != sizeof(AVInputFormat)) {                                                     \
+        av_log(NULL, AV_LOG_ERROR, "ijkav_register_##x##_demuxer: ABI mismatch.\n");               \
+        return -1;                                                                                  \
+    }                                                                                               \
+    memcpy(&ff_##x##_demuxer, demuxer, demuxer_size);                                            \
+    return 0;                                                                                       \
+}
+
+#define IJK_DUMMY_DEMUXER(x)                                        \
+IJK_FF_DEMUXER(x);                                                  \
+static const AVClass ijk_##x##_demuxer_class = {                    \
+    .class_name = #x,                                               \
+    .item_name  = av_default_item_name,                             \
+    .version    = LIBAVUTIL_VERSION_INT,                            \
+    };                                                              \
+                                                                    \
+AVInputFormat ff_##x##_demuxer = {                                  \
+    .name                = #x,                                      \
+    .priv_data_size      = 1,                                       \
+    .priv_class          = &ijk_##x##_demuxer_class,                \
+};
+
+IJK_DUMMY_DEMUXER(ijklivehook);
+IJK_DUMMY_DEMUXER(ijklas);
diff --git a/libavformat/isom.h b/libavformat/isom.h
index 5a6d5040907..84e8c0b78b4 100644
--- a/libavformat/isom.h
+++ b/libavformat/isom.h
@@ -294,6 +294,8 @@ typedef struct MOVContext {
     uint8_t *decryption_key;
     int decryption_key_len;
     int enable_drefs;
+    int allow_multi_extradata;
+    int has_extradata;
     int32_t movie_display_matrix[3][3]; ///< display matrix from mvhd
     int have_read_mfra_size;
     uint32_t mfra_size;
diff --git a/libavformat/mov.c b/libavformat/mov.c
index 4af796ee31c..90bf9468717 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -1946,8 +1946,18 @@ static int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         if (type == MKTAG('f','i','e','l') && size == atom.size)
             return mov_read_default(c, pb, atom);
     }
+    c->has_extradata = 1;
     if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {
+<<<<<<< ours
         av_log(c->fc, AV_LOG_WARNING, "ignoring multiple glbl\n");
+=======
+        if (c->allow_multi_extradata) {
+            av_log(c, AV_LOG_WARNING, "found multiple glbl\n");
+        } else {
+            av_log(c, AV_LOG_WARNING, "ignoring multiple glbl\n");
+            return 0;
+        }
+>>>>>>> theirs
         return 0;
     }
     ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);
@@ -7830,8 +7840,13 @@ fail:
 static AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)
 {
     AVIndexEntry *sample = NULL;
+    AVIndexEntry *best_dts_sample = NULL;
+    AVIndexEntry *best_pos_sample = NULL;
+    AVStream *best_dts_stream = NULL;
+    AVStream *best_pos_stream = NULL;
     int64_t best_dts = INT64_MAX;
     int i;
+    int64_t pos = avio_tell(s->pb);
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *avst = s->streams[i];
         MOVStreamContext *msc = avst->priv_data;
@@ -7839,17 +7854,41 @@ static AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)
             AVIndexEntry *current_sample = &avst->index_entries[msc->current_sample];
             int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);
             av_log(s, AV_LOG_TRACE, "stream %d, sample %d, dts %"PRId64"\n", i, msc->current_sample, dts);
-            if (!sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < sample->pos) ||
+            if (!best_dts_sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < best_dts_sample->pos) ||
                 ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) &&
+<<<<<<< ours
                  ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb && dts != AV_NOPTS_VALUE &&
                  ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||
+=======
+                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&
+                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < best_dts_sample->pos) ||
+>>>>>>> theirs
                   (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {
-                sample = current_sample;
+                /* find best dts sample */
+                best_dts_sample = current_sample;
                 best_dts = dts;
-                *st = avst;
+                best_dts_stream = avst;
+            }
+            if (current_sample->pos >= pos &&
+                (!best_pos_sample || current_sample->pos < best_pos_sample->pos)) {
+                /* find nearest sample to avoid seek around */
+                best_pos_sample = current_sample;
+                best_pos_stream = avst;
             }
         }
     }
+
+    if (best_dts_sample && best_dts_sample != best_pos_sample &&
+        (!best_pos_sample ||
+         best_dts_sample->pos < pos ||
+         best_dts_sample->pos > pos + 1024 * 1024)) {
+        sample = best_dts_sample;
+        *st = best_dts_stream;
+    } else {
+        sample = best_pos_sample;
+        *st = best_pos_stream;
+    }
+
     return sample;
 }
 
@@ -8074,6 +8113,12 @@ static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
                 return ret;
         }
     }
+    if (mov->allow_multi_extradata && mov->has_extradata) {
+        mov->has_extradata = 0;
+        ret = mov_change_extradata(sc, pkt);
+        if (ret < 0)
+            return ret;
+    }
 
     if (mov->aax_mode)
         aax_filter(pkt->data, pkt->size, mov);
@@ -8276,6 +8321,8 @@ static const AVOption mov_options[] = {
     { "enable_drefs", "Enable external track support.", OFFSET(enable_drefs), AV_OPT_TYPE_BOOL,
         {.i64 = 0}, 0, 1, FLAGS },
 
+    {"allow_multi_extradata", "", OFFSET(allow_multi_extradata), AV_OPT_TYPE_BOOL, {.i64 = 0},
+        0, 1, FLAGS},
     { NULL },
 };
 
diff --git a/libavformat/network.c b/libavformat/network.c
index 0f5a575f773..5d0e5bf36cb 100644
--- a/libavformat/network.c
+++ b/libavformat/network.c
@@ -524,6 +524,52 @@ int ff_connect_parallel(struct addrinfo *addrs, int timeout_ms_per_address,
     return last_err;
 }
 
+int ff_sendto(int fd, const char *msg, int msg_len, int flag,
+                      const struct sockaddr *addr,
+                      socklen_t addrlen, int timeout, URLContext *h,
+                      int will_try_next)
+{
+    struct pollfd p = {fd, POLLOUT, 0};
+    int ret;
+    socklen_t optlen;
+
+    if (ff_socket_nonblock(fd, 1) < 0)
+        av_log(NULL, AV_LOG_INFO, "ff_socket_nonblock failed\n");
+
+    while ((ret = sendto(fd, msg, msg_len, flag, addr, addrlen)) < 0) {
+        ret = ff_neterrno();
+        switch (ret) {
+        case AVERROR(EINTR):
+            if (ff_check_interrupt(&h->interrupt_callback))
+                return AVERROR_EXIT;
+            continue;
+        case AVERROR(EINPROGRESS):
+        case AVERROR(EAGAIN):
+            ret = ff_poll_interrupt(&p, 1, timeout, &h->interrupt_callback);
+            if (ret < 0)
+                return ret;
+            optlen = sizeof(ret);
+            if (getsockopt (fd, SOL_SOCKET, SO_ERROR, &ret, &optlen))
+                ret = AVUNERROR(ff_neterrno());
+            if (ret != 0) {
+                char errbuf[100];
+                ret = AVERROR(ret);
+                av_strerror(ret, errbuf, sizeof(errbuf));
+                if (will_try_next)
+                    av_log(h, AV_LOG_WARNING,
+                           "Connection to %s failed (%s), trying next address\n",
+                           h->filename, errbuf);
+                else
+                    av_log(h, AV_LOG_ERROR, "Connection to %s failed: %s\n",
+                           h->filename, errbuf);
+            }
+        default:
+            return ret;
+        }
+    }
+    return ret;
+}
+
 static int match_host_pattern(const char *pattern, const char *hostname)
 {
     int len_p, len_h;
diff --git a/libavformat/network.h b/libavformat/network.h
index 71347e815b0..534aaf86b26 100644
--- a/libavformat/network.h
+++ b/libavformat/network.h
@@ -303,6 +303,11 @@ int ff_listen_connect(int fd, const struct sockaddr *addr,
                       socklen_t addrlen, int timeout,
                       URLContext *h, int will_try_next);
 
+int ff_sendto(int fd, const char *msg, int msg_len, int flag,
+                      const struct sockaddr *addr,
+                      socklen_t addrlen, int timeout, URLContext *h,
+                      int will_try_next);
+
 int ff_http_match_no_proxy(const char *no_proxy, const char *hostname);
 
 int ff_socket(int domain, int type, int protocol);
diff --git a/libavformat/protocols.c b/libavformat/protocols.c
index fb6fabdce57..637f116ac6e 100644
--- a/libavformat/protocols.c
+++ b/libavformat/protocols.c
@@ -40,6 +40,12 @@ extern const URLProtocol ff_http_protocol;
 extern const URLProtocol ff_httpproxy_protocol;
 extern const URLProtocol ff_https_protocol;
 extern const URLProtocol ff_icecast_protocol;
+extern const URLProtocol ff_ijkhttphook_protocol;
+extern const URLProtocol ff_ijklongurl_protocol;
+extern const URLProtocol ff_ijkmediadatasource_protocol;
+extern const URLProtocol ff_ijksegment_protocol;
+extern const URLProtocol ff_ijktcphook_protocol;
+extern const URLProtocol ff_ijkio_protocol;
 extern const URLProtocol ff_mmsh_protocol;
 extern const URLProtocol ff_mmst_protocol;
 extern const URLProtocol ff_md5_protocol;
diff --git a/libavformat/tcp.c b/libavformat/tcp.c
index 2198e0f00e2..97b17e4f5d6 100644
--- a/libavformat/tcp.c
+++ b/libavformat/tcp.c
@@ -23,6 +23,8 @@
 #include "libavutil/parseutils.h"
 #include "libavutil/opt.h"
 #include "libavutil/time.h"
+#include "libavutil/application.h"
+#include "libavutil/dns_cache.h"
 
 #include "internal.h"
 #include "network.h"
@@ -31,6 +33,9 @@
 #if HAVE_POLL_H
 #include <poll.h>
 #endif
+#if HAVE_PTHREADS
+#include <pthread.h>
+#endif
 
 typedef struct TCPContext {
     const AVClass *class;
@@ -45,14 +50,29 @@ typedef struct TCPContext {
 #if !HAVE_WINSOCK2_H
     int tcp_mss;
 #endif /* !HAVE_WINSOCK2_H */
+    char * app_ctx_intptr;
+
+    int addrinfo_one_by_one;
+    int addrinfo_timeout;
+    int64_t dns_cache_timeout;
+    int dns_cache_clear;
+
+    AVApplicationContext *app_ctx;
+    char uri[1024];
+    int fastopen;
+    int tcp_connected;
+    int fastopen_success;
 } TCPContext;
 
+#define FAST_OPEN_FLAG 0x20000000
+
 #define OFFSET(x) offsetof(TCPContext, x)
 #define D AV_OPT_FLAG_DECODING_PARAM
 #define E AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
     { "listen",          "Listen for incoming connections",  OFFSET(listen),         AV_OPT_TYPE_INT, { .i64 = 0 },     0,       2,       .flags = D|E },
     { "timeout",     "set timeout (in microseconds) of socket I/O operations", OFFSET(rw_timeout),     AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
+    { "connect_timeout",  "set connect timeout (in microseconds) of socket", OFFSET(open_timeout),     AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "listen_timeout",  "Connection awaiting timeout (in milliseconds)",      OFFSET(listen_timeout), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "send_buffer_size", "Socket send buffer size (in bytes)",                OFFSET(send_buffer_size), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
     { "recv_buffer_size", "Socket receive buffer size (in bytes)",             OFFSET(recv_buffer_size), AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
@@ -60,6 +80,13 @@ static const AVOption options[] = {
 #if !HAVE_WINSOCK2_H
     { "tcp_mss",     "Maximum segment size for outgoing TCP packets",          OFFSET(tcp_mss),     AV_OPT_TYPE_INT, { .i64 = -1 },         -1, INT_MAX, .flags = D|E },
 #endif /* !HAVE_WINSOCK2_H */
+    { "ijkapplication",   "AVApplicationContext",                              OFFSET(app_ctx_intptr),   AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, .flags = D },
+
+    { "addrinfo_one_by_one",  "parse addrinfo one by one in getaddrinfo()",    OFFSET(addrinfo_one_by_one), AV_OPT_TYPE_INT, { .i64 = 0 },         0, 1, .flags = D|E },
+    { "addrinfo_timeout", "set timeout (in microseconds) for getaddrinfo()",   OFFSET(addrinfo_timeout), AV_OPT_TYPE_INT, { .i64 = -1 },       -1, INT_MAX, .flags = D|E },
+    { "dns_cache_timeout", "dns cache TTL (in microseconds)",   OFFSET(dns_cache_timeout), AV_OPT_TYPE_INT, { .i64 = 0 },       -1, INT64_MAX, .flags = D|E },
+    { "dns_cache_clear", "clear dns cache",   OFFSET(dns_cache_clear), AV_OPT_TYPE_INT, { .i64 = 0},       -1, INT_MAX, .flags = D|E },
+    { "fastopen", "enable fastopen",          OFFSET(fastopen), AV_OPT_TYPE_INT, { .i64 = 0},       0, INT_MAX, .flags = D|E },
     { NULL }
 };
 
@@ -98,6 +125,253 @@ static void customize_fd(void *ctx, int fd)
     }
 #endif /* !HAVE_WINSOCK2_H */
 }
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb, int one_by_one);
+#ifdef HAVE_PTHREADS
+
+typedef struct TCPAddrinfoRequest
+{
+    AVBufferRef *buffer;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+
+    AVIOInterruptCB interrupt_callback;
+
+    char            *hostname;
+    char            *servname;
+    struct addrinfo  hints;
+    struct addrinfo *res;
+
+    volatile int     finished;
+    int              last_error;
+} TCPAddrinfoRequest;
+
+static void tcp_getaddrinfo_request_free(TCPAddrinfoRequest *req)
+{
+    av_assert0(req);
+    if (req->res) {
+        freeaddrinfo(req->res);
+        req->res = NULL;
+    }
+
+    av_freep(&req->servname);
+    av_freep(&req->hostname);
+    pthread_cond_destroy(&req->cond);
+    pthread_mutex_destroy(&req->mutex);
+    av_freep(&req);
+}
+
+static void tcp_getaddrinfo_request_free_buffer(void *opaque, uint8_t *data)
+{
+    av_assert0(opaque);
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *)opaque;
+    tcp_getaddrinfo_request_free(req);
+}
+
+static int tcp_getaddrinfo_request_create(TCPAddrinfoRequest **request,
+                                          const char *hostname,
+                                          const char *servname,
+                                          const struct addrinfo *hints,
+                                          const AVIOInterruptCB *int_cb)
+{
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *) av_mallocz(sizeof(TCPAddrinfoRequest));
+    if (!req)
+        return AVERROR(ENOMEM);
+
+    if (pthread_mutex_init(&req->mutex, NULL)) {
+        av_freep(&req);
+        return AVERROR(ENOMEM);
+    }
+
+    if (pthread_cond_init(&req->cond, NULL)) {
+        pthread_mutex_destroy(&req->mutex);
+        av_freep(&req);
+        return AVERROR(ENOMEM);
+    }
+
+    if (int_cb)
+        req->interrupt_callback = *int_cb;
+
+    if (hostname) {
+        req->hostname = av_strdup(hostname);
+        if (!req->hostname)
+            goto fail;
+    }
+
+    if (servname) {
+        req->servname = av_strdup(servname);
+        if (!req->hostname)
+            goto fail;
+    }
+
+    if (hints) {
+        req->hints.ai_family   = hints->ai_family;
+        req->hints.ai_socktype = hints->ai_socktype;
+        req->hints.ai_protocol = hints->ai_protocol;
+        req->hints.ai_flags    = hints->ai_flags;
+    }
+
+    req->buffer = av_buffer_create(NULL, 0, tcp_getaddrinfo_request_free_buffer, req, 0);
+    if (!req->buffer)
+        goto fail;
+
+    *request = req;
+    return 0;
+fail:
+    tcp_getaddrinfo_request_free(req);
+    return AVERROR(ENOMEM);
+}
+
+static void *tcp_getaddrinfo_worker(void *arg)
+{
+    TCPAddrinfoRequest *req = arg;
+
+    getaddrinfo(req->hostname, req->servname, &req->hints, &req->res);
+    pthread_mutex_lock(&req->mutex);
+    req->finished = 1;
+    pthread_cond_signal(&req->cond);
+    pthread_mutex_unlock(&req->mutex);
+    av_buffer_unref(&req->buffer);
+    return NULL;
+}
+
+static void *tcp_getaddrinfo_one_by_one_worker(void *arg)
+{
+    struct addrinfo *temp_addrinfo = NULL;
+    struct addrinfo *cur = NULL;
+    int ret = EAI_FAIL;
+    int i = 0;
+    int option_length = 0;
+
+    TCPAddrinfoRequest *req = (TCPAddrinfoRequest *)arg;
+
+    int family_option[2] = {AF_INET, AF_INET6};
+
+    option_length = sizeof(family_option) / sizeof(family_option[0]);
+
+    for (; i < option_length; ++i) {
+        struct addrinfo *hint = &req->hints;
+        hint->ai_family = family_option[i];
+        ret = getaddrinfo(req->hostname, req->servname, hint, &temp_addrinfo);
+        if (ret) {
+            req->last_error = ret;
+            continue;
+        }
+        pthread_mutex_lock(&req->mutex);
+        if (!req->res) {
+            req->res = temp_addrinfo;
+        } else {
+            cur = req->res;
+            while (cur->ai_next)
+                cur = cur->ai_next;
+            cur->ai_next = temp_addrinfo;
+        }
+        pthread_mutex_unlock(&req->mutex);
+    }
+    pthread_mutex_lock(&req->mutex);
+    req->finished = 1;
+    pthread_cond_signal(&req->cond);
+    pthread_mutex_unlock(&req->mutex);
+    av_buffer_unref(&req->buffer);
+    return NULL;
+}
+
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb, int one_by_one)
+{
+    int     ret;
+    int64_t start;
+    int64_t now;
+    AVBufferRef        *req_ref = NULL;
+    TCPAddrinfoRequest *req     = NULL;
+    pthread_t work_thread;
+
+    if (hostname && !hostname[0])
+        hostname = NULL;
+
+    if (timeout <= 0)
+        return getaddrinfo(hostname, servname, hints, res);
+
+    ret = tcp_getaddrinfo_request_create(&req, hostname, servname, hints, int_cb);
+    if (ret)
+        goto fail;
+
+    req_ref = av_buffer_ref(req->buffer);
+    if (req_ref == NULL) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    /* FIXME: using a thread pool would be better. */
+    if (one_by_one)
+        ret = pthread_create(&work_thread, NULL, tcp_getaddrinfo_one_by_one_worker, req);
+    else
+        ret = pthread_create(&work_thread, NULL, tcp_getaddrinfo_worker, req);
+
+    if (ret) {
+        ret = AVERROR(ret);
+        goto fail;
+    }
+
+    pthread_detach(work_thread);
+
+    start = av_gettime();
+    now   = start;
+
+    pthread_mutex_lock(&req->mutex);
+    while (1) {
+        int64_t wait_time = now + 100000;
+        struct timespec tv = { .tv_sec  =  wait_time / 1000000,
+                               .tv_nsec = (wait_time % 1000000) * 1000 };
+
+        if (req->finished || (start + timeout < now)) {
+            if (req->res) {
+                ret = 0;
+                *res = req->res;
+                req->res = NULL;
+            } else {
+                ret = req->last_error ? req->last_error : AVERROR_EXIT;
+            }
+            break;
+        }
+#if defined(__ANDROID__) && defined(HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC)
+        ret = pthread_cond_timedwait_monotonic_np(&req->cond, &req->mutex, &tv);
+#else
+        ret = pthread_cond_timedwait(&req->cond, &req->mutex, &tv);
+#endif
+        if (ret != 0 && ret != ETIMEDOUT) {
+            av_log(NULL, AV_LOG_ERROR, "pthread_cond_timedwait failed: %d\n", ret);
+            ret = AVERROR_EXIT;
+            break;
+        }
+
+        if (ff_check_interrupt(&req->interrupt_callback)) {
+            ret = AVERROR_EXIT;
+            break;
+        }
+
+        now = av_gettime();
+    }
+    pthread_mutex_unlock(&req->mutex);
+fail:
+    av_buffer_unref(&req_ref);
+    return ret;
+}
+
+#else
+int ijk_tcp_getaddrinfo_nonblock(const char *hostname, const char *servname,
+                                 const struct addrinfo *hints, struct addrinfo **res,
+                                 int64_t timeout,
+                                 const AVIOInterruptCB *int_cb)
+{
+    return getaddrinfo(hostname, servname, hints, res);
+}
+#endif
 
 /* return non zero if error */
 static int tcp_open(URLContext *h, const char *uri, int flags)
@@ -110,7 +384,20 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
     int ret;
     char hostname[1024],proto[1024],path[1024];
     char portstr[10];
-    s->open_timeout = 5000000;
+    AVAppTcpIOControl control = {0};
+    DnsCacheEntry *dns_entry = NULL;
+
+    if (s->open_timeout < 0) {
+        s->open_timeout = 15000000;
+    }
+
+    s->app_ctx = (AVApplicationContext *)av_dict_strtoptr(s->app_ctx_intptr);
+
+    if (s->fastopen) {
+        s->tcp_connected = 0;
+        strcpy(s->uri, uri);
+        return 0;
+    }
 
     av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),
         &port, path, sizeof(path), uri);
@@ -131,32 +418,57 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
         }
         if (av_find_info_tag(buf, sizeof(buf), "timeout", p)) {
             s->rw_timeout = strtol(buf, NULL, 10);
+            if (s->rw_timeout >= 0) {
+                s->open_timeout = s->rw_timeout;
+            }
         }
         if (av_find_info_tag(buf, sizeof(buf), "listen_timeout", p)) {
             s->listen_timeout = strtol(buf, NULL, 10);
         }
     }
-    if (s->rw_timeout >= 0) {
-        s->open_timeout =
-        h->rw_timeout   = s->rw_timeout;
+    if (s->rw_timeout >= 0 ) {
+        h->rw_timeout = s->rw_timeout;
     }
+
     hints.ai_family = AF_UNSPEC;
     hints.ai_socktype = SOCK_STREAM;
     snprintf(portstr, sizeof(portstr), "%d", port);
     if (s->listen)
         hints.ai_flags |= AI_PASSIVE;
-    if (!hostname[0])
-        ret = getaddrinfo(NULL, portstr, &hints, &ai);
-    else
-        ret = getaddrinfo(hostname, portstr, &hints, &ai);
-    if (ret) {
-        av_log(h, AV_LOG_ERROR,
-               "Failed to resolve hostname %s: %s\n",
-               hostname, gai_strerror(ret));
-        return AVERROR(EIO);
+
+    if (s->dns_cache_timeout > 0) {
+        if (s->dns_cache_clear) {
+            av_log(NULL, AV_LOG_INFO, "will delete dns cache entry, uri = %s\n", uri);
+            remove_dns_cache_entry(uri);
+        } else {
+            dns_entry = get_dns_cache_reference(uri);
+        }
     }
 
-    cur_ai = ai;
+    if (!dns_entry) {
+#ifdef HAVE_PTHREADS
+        ret = ijk_tcp_getaddrinfo_nonblock(hostname, portstr, &hints, &ai, s->addrinfo_timeout, &h->interrupt_callback, s->addrinfo_one_by_one);
+#else
+        if (s->addrinfo_timeout > 0)
+            av_log(h, AV_LOG_WARNING, "Ignore addrinfo_timeout without pthreads support.\n");
+        if (!hostname[0])
+            ret = getaddrinfo(NULL, portstr, &hints, &ai);
+        else
+            ret = getaddrinfo(hostname, portstr, &hints, &ai);
+#endif
+
+        if (ret) {
+            av_log(h, AV_LOG_ERROR,
+                "Failed to resolve hostname %s: %s\n",
+                hostname, gai_strerror(ret));
+            return AVERROR(EIO);
+        }
+
+        cur_ai = ai;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "hit dns cache uri = %s\n", uri);
+        cur_ai = dns_entry->res;
+    }
 
 #if HAVE_STRUCT_SOCKADDR_IN6
     // workaround for IOS9 getaddrinfo in IPv6 only network use hardcode IPv4 address can not resolve port number.
@@ -195,21 +507,253 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
         // Socket descriptor already closed here. Safe to overwrite to client one.
         fd = ret;
     } else {
+<<<<<<< ours
         ret = ff_connect_parallel(ai, s->open_timeout / 1000, 3, h, &fd, customize_fd, s);
         if (ret < 0)
             goto fail1;
+=======
+        ret = av_application_on_tcp_will_open(s->app_ctx);
+        if (ret) {
+            av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_WILL_TCP_OPEN");
+            goto fail1;
+        }
+
+        if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,
+                                     s->open_timeout / 1000, h, !!cur_ai->ai_next)) < 0) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_CONNECT_TIMEOUT;
+            }
+            if (av_application_on_tcp_did_open(s->app_ctx, ret, fd, &control))
+                goto fail1;
+            if (ret == AVERROR_EXIT)
+                goto fail1;
+            else
+                goto fail;
+        } else {
+            ret = av_application_on_tcp_did_open(s->app_ctx, 0, fd, &control);
+            if (ret) {
+                av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_DID_TCP_OPEN");
+                goto fail1;
+            } else if (!dns_entry && !strstr(uri, control.ip) && s->dns_cache_timeout > 0) {
+                add_dns_cache_entry(uri, cur_ai, s->dns_cache_timeout);
+                av_log(NULL, AV_LOG_INFO, "add dns cache uri = %s, ip = %s\n", uri , control.ip);
+            }
+            av_log(NULL, AV_LOG_INFO, "tcp did open uri = %s, ip = %s\n", uri , control.ip);
+        }
+    }
+
+    h->is_streamed = 1;
+    s->fd = fd;
+
+    if (dns_entry) {
+        release_dns_cache_reference(uri, &dns_entry);
+    } else {
+        freeaddrinfo(ai);
+    }
+    return 0;
+
+ fail:
+    if (cur_ai->ai_next) {
+        /* Retry with the next sockaddr */
+        cur_ai = cur_ai->ai_next;
+        if (fd >= 0)
+            closesocket(fd);
+        ret = 0;
+        goto restart;
+    }
+ fail1:
+    if (fd >= 0)
+        closesocket(fd);
+
+    if (dns_entry) {
+        av_log(NULL, AV_LOG_ERROR, "hit dns cache but connect fail uri = %s, ip = %s\n", uri , control.ip);
+        release_dns_cache_reference(uri, &dns_entry);
+        remove_dns_cache_entry(uri);
+    } else {
+        freeaddrinfo(ai);
+    }
+
+    return ret;
+}
+
+/* return non zero if error */
+static int tcp_fast_open(URLContext *h, const char *http_request, const char *uri, int flags)
+{
+    struct addrinfo hints = { 0 }, *ai, *cur_ai;
+    int port, fd = -1;
+    TCPContext *s = h->priv_data;
+    const char *p;
+    char buf[256];
+    int ret;
+    char hostname[1024],proto[1024],path[1024];
+    char portstr[10];
+    AVAppTcpIOControl control = {0};
+    DnsCacheEntry *dns_entry = NULL;
+    av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),
+        &port, path, sizeof(path), uri);
+    if (strcmp(proto, "tcp"))
+        return AVERROR(EINVAL);
+    if (port <= 0 || port >= 65536) {
+        av_log(h, AV_LOG_ERROR, "Port missing in uri\n");
+        return AVERROR(EINVAL);
+    }
+    p = strchr(uri, '?');
+
+    if (p) {
+        if (av_find_info_tag(buf, sizeof(buf), "listen", p)) {
+            char *endptr = NULL;
+            s->listen = strtol(buf, &endptr, 10);
+            /* assume if no digits were found it is a request to enable it */
+            if (buf == endptr)
+                s->listen = 1;
+        }
+        if (av_find_info_tag(buf, sizeof(buf), "timeout", p)) {
+            s->rw_timeout = strtol(buf, NULL, 10);
+            if (s->rw_timeout >= 0) {
+                s->open_timeout = s->rw_timeout;
+            }
+        }
+        if (av_find_info_tag(buf, sizeof(buf), "listen_timeout", p)) {
+            s->listen_timeout = strtol(buf, NULL, 10);
+        }
+    }
+    if (s->rw_timeout >= 0 ) {
+        h->rw_timeout = s->rw_timeout;
+    }
+
+    hints.ai_family = AF_UNSPEC;
+    hints.ai_socktype = SOCK_STREAM;
+    snprintf(portstr, sizeof(portstr), "%d", port);
+    if (s->listen)
+        hints.ai_flags |= AI_PASSIVE;
+
+    if (s->dns_cache_timeout > 0) {
+        if (s->dns_cache_clear) {
+            av_log(NULL, AV_LOG_INFO, "will delete dns cache entry, uri = %s\n", uri);
+            remove_dns_cache_entry(uri);
+        } else {
+            dns_entry = get_dns_cache_reference(uri);
+        }
+    }
+
+    if (!dns_entry) {
+#ifdef HAVE_PTHREADS
+        ret = ijk_tcp_getaddrinfo_nonblock(hostname, portstr, &hints, &ai, s->addrinfo_timeout, &h->interrupt_callback, s->addrinfo_one_by_one);
+#else
+        if (s->addrinfo_timeout > 0)
+            av_log(h, AV_LOG_WARNING, "Ignore addrinfo_timeout without pthreads support.\n");
+        if (!hostname[0])
+            ret = getaddrinfo(NULL, portstr, &hints, &ai);
+        else
+            ret = getaddrinfo(hostname, portstr, &hints, &ai);
+#endif
+
+        if (ret) {
+            av_log(h, AV_LOG_ERROR,
+                "Failed to resolve hostname %s: %s\n",
+                hostname, gai_strerror(ret));
+            return AVERROR(EIO);
+        }
+
+        cur_ai = ai;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "hit dns cache uri = %s\n", uri);
+        cur_ai = dns_entry->res;
+    }
+
+ restart:
+#if HAVE_STRUCT_SOCKADDR_IN6
+    // workaround for IOS9 getaddrinfo in IPv6 only network use hardcode IPv4 address can not resolve port number.
+    if (cur_ai->ai_family == AF_INET6){
+        struct sockaddr_in6 * sockaddr_v6 = (struct sockaddr_in6 *)cur_ai->ai_addr;
+        if (!sockaddr_v6->sin6_port){
+            sockaddr_v6->sin6_port = htons(port);
+        }
+    }
+#endif
+    fd = ff_socket(cur_ai->ai_family,
+                   cur_ai->ai_socktype,
+                   cur_ai->ai_protocol);
+    if (fd < 0) {
+        ret = ff_neterrno();
+        goto fail;
+    }
+    /* Set the socket's send or receive buffer sizes, if specified.
+       If unspecified or setting fails, system default is used. */
+    if (s->recv_buffer_size > 0) {
+        setsockopt (fd, SOL_SOCKET, SO_RCVBUF, &s->recv_buffer_size, sizeof (s->recv_buffer_size));
+    }
+    if (s->send_buffer_size > 0) {
+        setsockopt (fd, SOL_SOCKET, SO_SNDBUF, &s->send_buffer_size, sizeof (s->send_buffer_size));
+    }
+    if (s->listen == 2) {
+        // multi-client
+        if ((ret = ff_listen(fd, cur_ai->ai_addr, cur_ai->ai_addrlen)) < 0)
+            goto fail1;
+    } else if (s->listen == 1) {
+        // single client
+        if ((ret = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,
+                                  s->listen_timeout, h)) < 0)
+            goto fail1;
+        // Socket descriptor already closed here. Safe to overwrite to client one.
+        fd = ret;
+    } else {
+        ret = av_application_on_tcp_will_open(s->app_ctx);
+        if (ret) {
+            av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_WILL_TCP_OPEN");
+            goto fail1;
+        }
+
+        if ((ret = ff_sendto(fd, http_request, strlen(http_request), FAST_OPEN_FLAG,
+                 cur_ai->ai_addr, cur_ai->ai_addrlen, s->open_timeout / 1000, h, !!cur_ai->ai_next)) < 0) {
+            s->fastopen_success = 0;
+            if (av_application_on_tcp_did_open(s->app_ctx, ret, fd, &control))
+                goto fail1;
+            if (ret == AVERROR_EXIT)
+                goto fail1;
+            else
+                goto fail;
+        } else {
+            if (ret == 0) {
+                s->fastopen_success = 0;
+            } else {
+                s->fastopen_success = 1;
+            }
+            ret = av_application_on_tcp_did_open(s->app_ctx, 0, fd, &control);
+            if (ret) {
+                av_log(NULL, AV_LOG_WARNING, "terminated by application in AVAPP_CTRL_DID_TCP_OPEN");
+                goto fail1;
+            } else if (!dns_entry && !strstr(uri, control.ip) && s->dns_cache_timeout > 0) {
+                add_dns_cache_entry(uri, cur_ai, s->dns_cache_timeout);
+                av_log(NULL, AV_LOG_INFO, "add dns cache uri = %s, ip = %s\n", uri , control.ip);
+            }
+            av_log(NULL, AV_LOG_INFO, "tcp did open uri = %s, ip = %s\n", uri , control.ip);
+        }
+>>>>>>> theirs
     }
 
     h->is_streamed = 1;
     s->fd = fd;
 
-    freeaddrinfo(ai);
+    if (dns_entry) {
+        release_dns_cache_reference(uri, &dns_entry);
+    } else {
+        freeaddrinfo(ai);
+    }
     return 0;
 
  fail1:
     if (fd >= 0)
         closesocket(fd);
-    freeaddrinfo(ai);
+
+    if (dns_entry) {
+        av_log(NULL, AV_LOG_ERROR, "hit dns cache but connect fail uri = %s, ip = %s\n", uri , control.ip);
+        release_dns_cache_reference(uri, &dns_entry);
+        remove_dns_cache_entry(uri);
+    } else {
+        freeaddrinfo(ai);
+    }
+
     return ret;
 }
 
@@ -238,12 +782,18 @@ static int tcp_read(URLContext *h, uint8_t *buf, int size)
 
     if (!(h->flags & AVIO_FLAG_NONBLOCK)) {
         ret = ff_network_wait_fd_timeout(s->fd, 0, h->rw_timeout, &h->interrupt_callback);
-        if (ret)
+        if (ret) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_READ_TIMEOUT;
+            }
             return ret;
+        }
     }
     ret = recv(s->fd, buf, size, 0);
     if (ret == 0)
         return AVERROR_EOF;
+    if (ret > 0)
+        av_application_did_io_tcp_read(s->app_ctx, (void*)h, ret);
     return ret < 0 ? ff_neterrno() : ret;
 }
 
@@ -254,9 +804,32 @@ static int tcp_write(URLContext *h, const uint8_t *buf, int size)
 
     if (!(h->flags & AVIO_FLAG_NONBLOCK)) {
         ret = ff_network_wait_fd_timeout(s->fd, 1, h->rw_timeout, &h->interrupt_callback);
-        if (ret)
+        if (ret) {
+            if (ret == AVERROR(ETIMEDOUT)) {
+                ret = AVERROR_TCP_WRITE_TIMEOUT;
+            }
+            return ret;
+        }
+    }
+
+    if (s->fastopen && !s->tcp_connected && av_stristart(buf, "GET", NULL)) {
+        ret = tcp_fast_open(h, buf, s->uri, 0);
+        if (!ret) {
+            s->tcp_connected = 1;
+            if (!s->fastopen_success) {
+                ret = send(s->fd, buf, size, MSG_NOSIGNAL);
+                if (ret > 0) {
+                    s->fastopen_success = 1;
+                }
+                return ret < 0 ? ff_neterrno() : ret;
+            }
             return ret;
+        } else {
+            av_log(NULL, AV_LOG_WARNING, "tcp_fast_open is error ret = %d\n", ret);
+            return ret;
+        }
     }
+
     ret = send(s->fd, buf, size, MSG_NOSIGNAL);
     return ret < 0 ? ff_neterrno() : ret;
 }
diff --git a/libavformat/utils.c b/libavformat/utils.c
index 75e5350a277..77bdb544d98 100644
--- a/libavformat/utils.c
+++ b/libavformat/utils.c
@@ -515,6 +515,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename,
     AVFormatContext *s = *ps;
     int i, ret = 0;
     AVDictionary *tmp = NULL;
+    AVDictionary *tmp2 = NULL;
     ID3v2ExtraMeta *id3v2_extra_meta = NULL;
 
     if (!s && !(s = avformat_alloc_context()))
@@ -601,13 +602,26 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (s->pb)
         ff_id3v2_read_dict(s->pb, &s->internal->id3v2_meta, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);
 
+<<<<<<< ours
 #if FF_API_DEMUXER_OPEN
     if (!(s->flags&AVFMT_FLAG_PRIV_OPT) && s->iformat->read_header)
 #else
     if (s->iformat->read_header)
 #endif
         if ((ret = s->iformat->read_header(s)) < 0)
+=======
+
+    if (!(s->flags&AVFMT_FLAG_PRIV_OPT)) {
+        if (s->iformat->read_header2) {
+            if (options)
+                av_dict_copy(&tmp2, *options, 0);
+
+            if ((ret = s->iformat->read_header2(s, &tmp2)) < 0)
+                goto fail;
+        } else if (s->iformat->read_header && (ret = s->iformat->read_header(s)) < 0)
+>>>>>>> theirs
             goto fail;
+    }
 
     if (!s->metadata) {
         s->metadata = s->internal->id3v2_meta;
@@ -651,6 +665,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (options) {
         av_dict_free(options);
         *options = tmp;
+        av_dict_free(&tmp2);
     }
     *ps = s;
     return 0;
@@ -661,6 +676,7 @@ close:
 fail:
     ff_id3v2_free_extra_meta(&id3v2_extra_meta);
     av_dict_free(&tmp);
+    av_dict_free(&tmp2);
     if (s->pb && !(s->flags & AVFMT_FLAG_CUSTOM_IO))
         avio_closep(&s->pb);
     avformat_free_context(s);
@@ -3617,6 +3633,64 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     int eof_reached = 0;
     int *missing_streams = av_opt_ptr(ic->iformat->priv_class, ic->priv_data, "missing_streams");
 
+    AVDictionaryEntry *t;
+
+    t = av_dict_get(ic->metadata, "nb-streams", NULL, AV_DICT_MATCH_CASE);
+    if (t) {
+        int nb_streams = (int) strtol(t->value, NULL, 10);
+        if (nb_streams > 0) {
+            int64_t read_size = 0;
+            int found_all_streams = 0;
+            while (!found_all_streams) {
+                if (read_size >= probesize) {
+                    av_log(NULL, AV_LOG_INFO, "probe fail\n");
+                    return ic->nb_streams;
+                }
+
+                ret = read_frame_internal(ic, &pkt1);
+                if (ret == AVERROR(EAGAIN))
+                    continue;
+                if (ret < 0) {
+                    /* EOF or error*/
+                    eof_reached = 1;
+                    break;
+                }
+                pkt = &pkt1;
+
+                if (!(ic->streams[pkt->stream_index]->disposition & AV_DISPOSITION_ATTACHED_PIC))
+                    read_size += pkt->size;
+
+                if (!(ic->flags & AVFMT_FLAG_NOBUFFER)) {
+                    ret = ff_packet_list_put(&ic->internal->raw_packet_buffer,
+                                             &ic->internal->raw_packet_buffer_end,
+                                             pkt,0);
+                    if (ret < 0)
+                        return ret;
+                }
+
+                for(i = 0; i < ic->nb_streams; i++) {
+                    int64_t cur_start_time = AV_NOPTS_VALUE;
+                    if (ic->streams[i]->start_time != AV_NOPTS_VALUE) {
+                        cur_start_time = av_rescale_q(ic->streams[i]->start_time,
+                                                        ic->streams[i]->time_base,
+                                                        AV_TIME_BASE_Q);
+                    }
+                    if (cur_start_time != AV_NOPTS_VALUE &&
+                        (ic->start_time == AV_NOPTS_VALUE || ic->start_time > cur_start_time)){
+                       ic->start_time = cur_start_time;
+                    }
+                }
+
+                if (ic->nb_streams >= nb_streams && ic->start_time != AV_NOPTS_VALUE) {
+                    av_log(NULL, AV_LOG_INFO, "probe pass\n");
+                    found_all_streams  = 1;
+                }
+            }
+            av_dict_set_int(&ic->metadata, "nb-streams", 0, 0);
+            return ret < 0 ? ret : ic->nb_streams;
+        }
+    }
+
     flush_codecs = probesize > 0;
 
     av_opt_set(ic, "skip_clear", "1", AV_OPT_SEARCH_CHILDREN);
@@ -3744,6 +3818,20 @@ FF_ENABLE_DEPRECATION_WARNINGS
             st = ic->streams[i];
             if (!has_codec_parameters(st, NULL))
                 break;
+
+            if (ic->metadata) {
+                AVDictionaryEntry *t = av_dict_get(ic->metadata, "skip-calc-frame-rate", NULL, AV_DICT_MATCH_CASE);
+                if (t) {
+                    int fps_flag = (int) strtol(t->value, NULL, 10);
+                    if (!st->r_frame_rate.num && st->avg_frame_rate.num > 0 && st->avg_frame_rate.den > 0 && fps_flag > 0) {
+                        int avg_fps = st->avg_frame_rate.num / st->avg_frame_rate.den;
+                        if (avg_fps > 0 && avg_fps <= 120) {
+                            st->r_frame_rate.num = st->avg_frame_rate.num;
+                            st->r_frame_rate.den = st->avg_frame_rate.den;
+                        }
+                    }
+                }
+            }
             /* If the timebase is coarse (like the usual millisecond precision
              * of mkv), we need to analyze more frames to reliably arrive at
              * the correct fps. */
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 27bafe9e126..8b363541915 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -4,6 +4,7 @@ DESC = FFmpeg utility library
 HEADERS = adler32.h                                                     \
           aes.h                                                         \
           aes_ctr.h                                                     \
+          application.h                                                 \
           attributes.h                                                  \
           audio_fifo.h                                                  \
           avassert.h                                                    \
@@ -26,6 +27,7 @@ HEADERS = adler32.h                                                     \
           dovi_meta.h                                                   \
           downmix_info.h                                                \
           encryption_info.h                                             \
+          dns_cache.h                                                   \
           error.h                                                       \
           eval.h                                                        \
           fifo.h                                                        \
@@ -85,6 +87,7 @@ HEADERS = adler32.h                                                     \
           tea.h                                                         \
           tx.h                                                          \
           film_grain_params.h                                           \
+          thread.h                                                      \
 
 HEADERS-$(CONFIG_LZO)                   += lzo.h
 
@@ -99,6 +102,7 @@ BUILT_HEADERS = avconfig.h                                              \
 OBJS = adler32.o                                                        \
        aes.o                                                            \
        aes_ctr.o                                                        \
+       application.o                                                    \
        audio_fifo.o                                                     \
        avstring.o                                                       \
        avsscanf.o                                                       \
@@ -118,6 +122,7 @@ OBJS = adler32.o                                                        \
        dovi_meta.o                                                      \
        downmix_info.o                                                   \
        encryption_info.o                                                \
+       dns_cache.o                                                      \
        error.o                                                          \
        eval.o                                                           \
        fifo.o                                                           \
diff --git a/libavutil/application.c b/libavutil/application.c
new file mode 100644
index 00000000000..99751876bd6
--- /dev/null
+++ b/libavutil/application.c
@@ -0,0 +1,214 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "application.h"
+#include "libavformat/network.h"
+#include "libavutil/avstring.h"
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event);
+
+int av_application_alloc(AVApplicationContext **ph, void *opaque)
+{
+    AVApplicationContext *h = NULL;
+
+    h = av_mallocz(sizeof(AVApplicationContext));
+    if (!h)
+        return AVERROR(ENOMEM);
+
+    h->opaque = opaque;
+
+    *ph = h;
+    return 0;
+}
+
+int av_application_open(AVApplicationContext **ph, void *opaque)
+{
+    int ret = av_application_alloc(ph, opaque);
+    if (ret)
+        return ret;
+
+    return 0;
+}
+
+void av_application_close(AVApplicationContext *h)
+{
+    av_free(h);
+}
+
+void av_application_closep(AVApplicationContext **ph)
+{
+    if (!ph || !*ph)
+        return;
+
+    av_application_close(*ph);
+    *ph = NULL;
+}
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, event_type, (void *)event, sizeof(AVAppHttpEvent));
+}
+
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_OPEN, &event);
+}
+
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+    event.filesize  = filesize;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_OPEN, &event);
+}
+
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+
+    av_application_on_http_event(h, AVAPP_EVENT_WILL_HTTP_SEEK, &event);
+}
+
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code)
+{
+    AVAppHttpEvent event = {0};
+
+    if (!h || !obj || !url)
+        return;
+
+    event.obj        = obj;
+    event.offset     = offset;
+    av_strlcpy(event.url, url, sizeof(event.url));
+    event.error     = error;
+    event.http_code = http_code;
+
+    av_application_on_http_event(h, AVAPP_EVENT_DID_HTTP_SEEK, &event);
+}
+
+void av_application_on_io_traffic(AVApplicationContext *h, AVAppIOTraffic *event)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_IO_TRAFFIC, (void *)event, sizeof(AVAppIOTraffic));
+}
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control)
+{
+    if (h && h->func_on_app_event)
+        return h->func_on_app_event(h, event_type, (void *)control, sizeof(AVAppIOControl));
+    return 0;
+}
+
+int av_application_on_tcp_will_open(AVApplicationContext *h)
+{
+    if (h && h->func_on_app_event) {
+        AVAppTcpIOControl control = {0};
+        return h->func_on_app_event(h, AVAPP_CTRL_WILL_TCP_OPEN, (void *)&control, sizeof(AVAppTcpIOControl));
+    }
+    return 0;
+}
+
+// only callback returns error
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control)
+{
+    struct sockaddr_storage so_stg;
+    int       ret = 0;
+    socklen_t so_len = sizeof(so_stg);
+    int       so_family;
+    char      *so_ip_name = control->ip;
+
+    if (!h || !h->func_on_app_event || fd <= 0)
+        return 0;
+
+    ret = getpeername(fd, (struct sockaddr *)&so_stg, &so_len);
+    if (ret)
+        return 0;
+    control->error = error;
+    control->fd = fd;
+
+    so_family = ((struct sockaddr*)&so_stg)->sa_family;
+    switch (so_family) {
+        case AF_INET: {
+            struct sockaddr_in* in4 = (struct sockaddr_in*)&so_stg;
+            if (inet_ntop(AF_INET, &(in4->sin_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET;
+                control->port = in4->sin_port;
+            }
+            break;
+        }
+        case AF_INET6: {
+            struct sockaddr_in6* in6 = (struct sockaddr_in6*)&so_stg;
+            if (inet_ntop(AF_INET6, &(in6->sin6_addr), so_ip_name, sizeof(control->ip))) {
+                control->family = AF_INET6;
+                control->port = in6->sin6_port;
+            }
+            break;
+        }
+    }
+
+    return h->func_on_app_event(h, AVAPP_CTRL_DID_TCP_OPEN, (void *)control, sizeof(AVAppTcpIOControl));
+}
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_STATISTIC, (void *)statistic, sizeof(AVAppAsyncStatistic));
+}
+
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed)
+{
+    if (h && h->func_on_app_event)
+        h->func_on_app_event(h, AVAPP_EVENT_ASYNC_READ_SPEED, (void *)speed, sizeof(AVAppAsyncReadSpeed));
+}
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes)
+{
+    AVAppIOTraffic event = {0};
+    if (!h || !obj || bytes <= 0)
+        return;
+
+    event.obj        = obj;
+    event.bytes      = bytes;
+
+    av_application_on_io_traffic(h, &event);
+}
diff --git a/libavutil/application.h b/libavutil/application.h
new file mode 100644
index 00000000000..72fe9027899
--- /dev/null
+++ b/libavutil/application.h
@@ -0,0 +1,121 @@
+/*
+ * copyright (c) 2016 Zhang Rui
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_APPLICATION_H
+#define AVUTIL_APPLICATION_H
+
+#include "libavutil/log.h"
+
+#define AVAPP_EVENT_WILL_HTTP_OPEN  1 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_OPEN   2 //AVAppHttpEvent
+#define AVAPP_EVENT_WILL_HTTP_SEEK  3 //AVAppHttpEvent
+#define AVAPP_EVENT_DID_HTTP_SEEK   4 //AVAppHttpEvent
+
+#define AVAPP_EVENT_ASYNC_STATISTIC     0x11000 //AVAppAsyncStatistic
+#define AVAPP_EVENT_ASYNC_READ_SPEED    0x11001 //AVAppAsyncReadSpeed
+#define AVAPP_EVENT_IO_TRAFFIC          0x12204 //AVAppIOTraffic
+
+#define AVAPP_CTRL_WILL_TCP_OPEN   0x20001 //AVAppTcpIOControl
+#define AVAPP_CTRL_DID_TCP_OPEN    0x20002 //AVAppTcpIOControl
+
+#define AVAPP_CTRL_WILL_HTTP_OPEN  0x20003 //AVAppIOControl
+#define AVAPP_CTRL_WILL_LIVE_OPEN  0x20005 //AVAppIOControl
+
+#define AVAPP_CTRL_WILL_CONCAT_SEGMENT_OPEN 0x20007 //AVAppIOControl
+
+typedef struct AVAppIOControl {
+    size_t  size;
+    char    url[4096];      /* in, out */
+    int     segment_index;  /* in, default = 0 */
+    int     retry_counter;  /* in */
+
+    int     is_handled;     /* out, default = false */
+    int     is_url_changed; /* out, default = false */
+} AVAppIOControl;
+
+typedef struct AVAppTcpIOControl {
+    int  error;
+    int  family;
+    char ip[96];
+    int  port;
+    int  fd;
+} AVAppTcpIOControl;
+
+typedef struct AVAppAsyncStatistic {
+    size_t  size;
+    int64_t buf_backwards;
+    int64_t buf_forwards;
+    int64_t buf_capacity;
+} AVAppAsyncStatistic;
+
+typedef struct AVAppAsyncReadSpeed {
+    size_t  size;
+    int     is_full_speed;
+    int64_t io_bytes;
+    int64_t elapsed_milli;
+} AVAppAsyncReadSpeed;
+
+typedef struct AVAppHttpEvent
+{
+    void    *obj;
+    char     url[4096];
+    int64_t  offset;
+    int      error;
+    int      http_code;
+    int64_t  filesize;
+} AVAppHttpEvent;
+
+typedef struct AVAppIOTraffic
+{
+    void   *obj;
+    int     bytes;
+} AVAppIOTraffic;
+
+typedef struct AVApplicationContext AVApplicationContext;
+struct AVApplicationContext {
+    const AVClass *av_class;    /**< information for av_log(). Set by av_application_open(). */
+    void *opaque;               /**< user data. */
+
+    int (*func_on_app_event)(AVApplicationContext *h, int event_type ,void *obj, size_t size);
+};
+
+int  av_application_alloc(AVApplicationContext **ph, void *opaque);
+int  av_application_open(AVApplicationContext **ph, void *opaque);
+void av_application_close(AVApplicationContext *h);
+void av_application_closep(AVApplicationContext **ph);
+
+void av_application_on_http_event(AVApplicationContext *h, int event_type, AVAppHttpEvent *event);
+void av_application_will_http_open(AVApplicationContext *h, void *obj, const char *url);
+void av_application_did_http_open(AVApplicationContext *h, void *obj, const char *url, int error, int http_code, int64_t filesize);
+void av_application_will_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset);
+void av_application_did_http_seek(AVApplicationContext *h, void *obj, const char *url, int64_t offset, int error, int http_code);
+
+void av_application_did_io_tcp_read(AVApplicationContext *h, void *obj, int bytes);
+
+int  av_application_on_io_control(AVApplicationContext *h, int event_type, AVAppIOControl *control);
+
+int av_application_on_tcp_will_open(AVApplicationContext *h);
+int av_application_on_tcp_did_open(AVApplicationContext *h, int error, int fd, AVAppTcpIOControl *control);
+
+void av_application_on_async_statistic(AVApplicationContext *h, AVAppAsyncStatistic *statistic);
+void av_application_on_async_read_speed(AVApplicationContext *h, AVAppAsyncReadSpeed *speed);
+
+
+#endif /* AVUTIL_APPLICATION_H */
diff --git a/libavutil/dict.c b/libavutil/dict.c
index 9d3d96c58b6..9ec8dfa17f1 100644
--- a/libavutil/dict.c
+++ b/libavutil/dict.c
@@ -42,7 +42,7 @@ AVDictionaryEntry *av_dict_get(const AVDictionary *m, const char *key,
 {
     unsigned int i, j;
 
-    if (!m)
+    if (!m || !key)
         return NULL;
 
     if (prev)
@@ -153,6 +153,43 @@ int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value,
     return av_dict_set(pm, key, valuestr, flags);
 }
 
+int av_dict_set_intptr(AVDictionary **pm, const char *key, uintptr_t value,
+                int flags)
+{
+    char valuestr[22];
+    snprintf(valuestr, sizeof(valuestr), "%p", value);
+    flags &= ~AV_DICT_DONT_STRDUP_VAL;
+    return av_dict_set(pm, key, valuestr, flags);
+}
+
+uintptr_t av_dict_get_intptr(const AVDictionary *m, const char* key) {
+    uintptr_t ptr = NULL;
+    AVDictionaryEntry *t = NULL;
+    if ((t = av_dict_get(m, key, NULL, 0))) {
+      return av_dict_strtoptr(t->value);
+    }
+    return NULL;
+}
+
+uintptr_t av_dict_strtoptr(char * value) {
+   uintptr_t ptr = NULL;
+   char *next = NULL;
+   if(!value || value[0] !='0' || (value[1]|0x20)!='x') {
+       return NULL;
+   }
+   ptr = strtoull(value, &next, 16);
+   if (next == value) {
+       return NULL;
+   }
+   return ptr;
+}
+
+char * av_dict_ptrtostr(uintptr_t value) {
+    char valuestr[22] = {0};
+    snprintf(valuestr, sizeof(valuestr), "%p", value);
+    return av_strdup(valuestr);
+}
+
 static int parse_key_value_pair(AVDictionary **pm, const char **buf,
                                 const char *key_val_sep, const char *pairs_sep,
                                 int flags)
diff --git a/libavutil/dict.h b/libavutil/dict.h
index 118f1f00ed2..9d6d8dfdfe6 100644
--- a/libavutil/dict.h
+++ b/libavutil/dict.h
@@ -137,6 +137,16 @@ int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags
  */
 int av_dict_set_int(AVDictionary **pm, const char *key, int64_t value, int flags);
 
+/**
+ * Convenience wrapper for av_dict_get that converts the value to a pointer
+ * and stores it.
+ *
+ */
+int av_dict_set_intptr(AVDictionary **pm, const char *key, uintptr_t value, int flags);
+uintptr_t av_dict_get_intptr(const AVDictionary *m, const char* key);
+uintptr_t av_dict_strtoptr(char * value);
+char * av_dict_ptrtostr(uintptr_t value);
+
 /**
  * Parse the key/value pairs list and add the parsed entries to a dictionary.
  *
diff --git a/libavutil/dns_cache.c b/libavutil/dns_cache.c
new file mode 100644
index 00000000000..5135c0a5ce6
--- /dev/null
+++ b/libavutil/dns_cache.c
@@ -0,0 +1,229 @@
+/*
+ * copyright (c) 2017 Raymond Zheng
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/dns_cache.h"
+#include "libavutil/time.h"
+#include "libavformat/network.h"
+
+#if HAVE_PTHREADS
+#include <pthread.h>
+#endif
+
+typedef struct DnsCacheContext DnsCacheContext;
+typedef struct DnsCacheContext {
+    AVDictionary *dns_dictionary;
+    pthread_mutex_t dns_dictionary_mutex;
+    int initialized;
+} DnsCacheContext;
+
+static DnsCacheContext *context = NULL;
+static pthread_once_t key_once = PTHREAD_ONCE_INIT;
+
+static void inner_init(void) {
+    int ret = 0;
+    context = (DnsCacheContext *) av_mallocz(sizeof(DnsCacheContext));
+    if (context) {
+        ret = pthread_mutex_init(&context->dns_dictionary_mutex, NULL);
+        if (!ret) {
+            context->initialized = 1;
+        } else {
+            av_freep(&context);
+        }
+    }
+}
+
+static void free_private_addrinfo(struct addrinfo **p_ai) {
+    struct addrinfo *ai = *p_ai;
+
+    if (ai) {
+        if (ai->ai_addr) {
+            av_freep(&ai->ai_addr);
+        }
+        av_freep(p_ai);
+    }
+}
+
+static int inner_remove_dns_cache(const char *uri, DnsCacheEntry *dns_cache_entry) {
+    if (context && dns_cache_entry) {
+        if (dns_cache_entry->ref_count == 0) {
+            av_dict_set_int(&context->dns_dictionary, uri, 0, 0);
+            free_private_addrinfo(&dns_cache_entry->res);
+            av_freep(&dns_cache_entry);
+        } else {
+            dns_cache_entry->delete_flag = 1;
+        }
+    }
+
+    return 0;
+}
+
+static DnsCacheEntry *new_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout) {
+    DnsCacheEntry *new_entry = NULL;
+    int64_t cur_time         = av_gettime_relative();
+
+    if (cur_time < 0) {
+        goto fail;
+    }
+
+    new_entry = (DnsCacheEntry *) av_mallocz(sizeof(struct DnsCacheEntry));
+    if (!new_entry) {
+        goto fail;
+    }
+
+    new_entry->res = (struct addrinfo *) av_mallocz(sizeof(struct addrinfo));
+    if (!new_entry->res) {
+        av_freep(&new_entry);
+        goto fail;
+    }
+
+    memcpy(new_entry->res, cur_ai, sizeof(struct addrinfo));
+
+    new_entry->res->ai_addr = (struct sockaddr *) av_mallocz(sizeof(struct sockaddr));
+    if (!new_entry->res->ai_addr) {
+        av_freep(&new_entry->res);
+        av_freep(&new_entry);
+        goto fail;
+    }
+
+    memcpy(new_entry->res->ai_addr, cur_ai->ai_addr, sizeof(struct sockaddr));
+    new_entry->res->ai_canonname = NULL;
+    new_entry->res->ai_next      = NULL;
+    new_entry->ref_count         = 0;
+    new_entry->delete_flag       = 0;
+    new_entry->expired_time      = cur_time + timeout * 1000;
+
+    return new_entry;
+
+fail:
+    return NULL;
+}
+
+DnsCacheEntry *get_dns_cache_reference(const char *uri) {
+    AVDictionaryEntry *elem = NULL;
+    DnsCacheEntry *dns_cache_entry = NULL;
+    int64_t cur_time = av_gettime_relative();
+
+    if (cur_time < 0 || !uri || strlen(uri) == 0) {
+        return NULL;
+    }
+
+    if (!context || !context->initialized) {
+#if HAVE_PTHREADS
+        pthread_once(&key_once, inner_init);
+#endif
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            dns_cache_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (dns_cache_entry) {
+                if (dns_cache_entry->expired_time < cur_time) {
+                    inner_remove_dns_cache(uri, dns_cache_entry);
+                    dns_cache_entry = NULL;
+                } else {
+                    dns_cache_entry->ref_count++;
+                }
+            }
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+
+    return dns_cache_entry;
+}
+
+int release_dns_cache_reference(const char *uri, DnsCacheEntry **p_entry) {
+    DnsCacheEntry *entry = *p_entry;
+
+    if (!uri || strlen(uri) == 0) {
+        return -1;
+    }
+
+    if (context && context->initialized && entry) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        entry->ref_count--;
+        if (entry->delete_flag && entry->ref_count == 0) {
+            inner_remove_dns_cache(uri, entry);
+            entry = NULL;
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+    return 0;
+}
+
+int remove_dns_cache_entry(const char *uri) {
+    AVDictionaryEntry *elem = NULL;
+    DnsCacheEntry *dns_cache_entry = NULL;
+
+    if (!uri || strlen(uri) == 0) {
+        return -1;
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            dns_cache_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (dns_cache_entry) {
+                inner_remove_dns_cache(uri, dns_cache_entry);
+            }
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+    }
+
+    return 0;
+}
+
+int add_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout) {
+    DnsCacheEntry *new_entry = NULL;
+    DnsCacheEntry *old_entry = NULL;
+    AVDictionaryEntry *elem  = NULL;
+
+    if (!uri || strlen(uri) == 0 || timeout <= 0) {
+        goto fail;
+    }
+
+    if (cur_ai == NULL || cur_ai->ai_addr == NULL) {
+        goto fail;
+    }
+
+    if (context && context->initialized) {
+        pthread_mutex_lock(&context->dns_dictionary_mutex);
+        elem = av_dict_get(context->dns_dictionary, uri, NULL, AV_DICT_MATCH_CASE);
+        if (elem) {
+            old_entry = (DnsCacheEntry *) (intptr_t) strtoll(elem->value, NULL, 10);
+            if (old_entry) {
+                pthread_mutex_unlock(&context->dns_dictionary_mutex);
+                goto fail;
+            }
+        }
+        new_entry = new_dns_cache_entry(uri, cur_ai, timeout);
+        if (new_entry) {
+            av_dict_set_int(&context->dns_dictionary, uri, (int64_t) (intptr_t) new_entry, 0);
+        }
+        pthread_mutex_unlock(&context->dns_dictionary_mutex);
+
+        return 0;
+    }
+
+fail:
+    return -1;
+}
diff --git a/libavutil/dns_cache.h b/libavutil/dns_cache.h
new file mode 100644
index 00000000000..69b47bbc437
--- /dev/null
+++ b/libavutil/dns_cache.h
@@ -0,0 +1,38 @@
+/*
+ * copyright (c) 2017 Raymond Zheng
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_DNS_CACHE_H
+#define AVUTIL_DNS_CACHE_H
+
+#include "libavutil/log.h"
+
+typedef struct DnsCacheEntry {
+    volatile int ref_count;
+    volatile int delete_flag;
+    int64_t expired_time;
+    struct addrinfo *res;  // construct by private function, not support ai_next and ai_canonname, can only be released using free_private_addrinfo
+} DnsCacheEntry;
+
+DnsCacheEntry *get_dns_cache_reference(const char *uri);
+int release_dns_cache_reference(const char *uri, DnsCacheEntry **p_entry);
+int remove_dns_cache_entry(const char *uri);
+int add_dns_cache_entry(const char *uri, struct addrinfo *cur_ai, int64_t timeout);
+
+#endif /* AVUTIL_DNS_CACHE_H */
diff --git a/libavutil/error.h b/libavutil/error.h
index 71df4da353b..6b44d2cd22f 100644
--- a/libavutil/error.h
+++ b/libavutil/error.h
@@ -82,6 +82,10 @@
 
 #define AV_ERROR_MAX_STRING_SIZE 64
 
+#define AVERROR_TCP_CONNECT_TIMEOUT -1001
+#define AVERROR_TCP_READ_TIMEOUT -1002
+#define AVERROR_TCP_WRITE_TIMEOUT -1003
+
 /**
  * Put a description of the AVERROR code errnum in errbuf.
  * In case of failure the global variable errno is set to indicate the
-- 
2.30.1 (Apple Git-130)

